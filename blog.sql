-- MySQL dump 10.13  Distrib 5.7.30, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.30

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `admin_user`
--

DROP TABLE IF EXISTS `admin_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `admin_user` (
  `username` varchar(100) DEFAULT NULL,
  `password` varchar(200) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `admin_user`
--

LOCK TABLES `admin_user` WRITE;
/*!40000 ALTER TABLE `admin_user` DISABLE KEYS */;
INSERT INTO `admin_user` VALUES ('chauncey','mengxiangyu123');
/*!40000 ALTER TABLE `admin_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `article` (
  `isDraft` tinyint(1) DEFAULT NULL,
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `type_id` int(11) DEFAULT NULL,
  `title` varchar(100) DEFAULT NULL,
  `article_content` text,
  `introduce` text,
  `addTime` int(100) DEFAULT NULL,
  `view_count` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (0,21,1,'本博客浏览器跨域问题','## 博客基本结构\n- 前台: 利用 react-next 搭建, blog\n- 中台: 利用 eggjs 搭建, blog-server\n- 后台: 利用 react 搭建, blog-admin\n\n整个项目由 mysql 串联\n\n## 发现跨域问题\n\n> 问题描述: 因为后台的`blog-admin`管理博客系统需要登录权限, 所以我用 egg-cors 设置了以下配置\n\n```js\nconfig.cors = {\n    origin: \'*\',\n    credentials: true,\n    allowMethods: \'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS\'\n  }\n```\n但是由于设置了 withCredentials 属性不能把 origin 设置成 * 号\n[详见MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)\n\n所以我就把 origin 改回我的`blog-admin`请求地址, 但是这样的话前台的数据就请求不到了, 因为 origin 只匹配到`blog-admin`管理系统的地址\n\n那这时候我就想能不能设置两个 origin, 于是我改成这样\n\n```js\nconfig.cors = {\n    origin: [\'blog-admin源\',\'blog源\'],\n    credentials: true,\n    allowMethods: \'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS\'\n  }\n```\n还是不行, 报错显示只能设置一个源, 所以我就在网上搜啊搜, 找了好多种方案, 都不行  : (\n\n## 分析跨域问题\n\n**搜索不出来, 于是我就想要不自己写一个插件来解决这种需求, 然后我就看 [egg-cors 的源码](https://github.com/eggjs/egg-cors) 他是怎么写的**\n\n看了之后发现它直接引入的是 @koa/cors 插件, 什么都没有做, 我心想这不是多此一举么, 怪不得介绍上写着支持 @koa/cors 的所有功能\n\n**于是我就去看 [@koa/cors 的源码](https://github.com/koajs/cors)**\n\n大概扫了一遍发现就是对一些原生设置 cors 的一些封装, 不过在参数简介的时候一句话引起了我的注意(**解决的关键**)\n\n```js\n*  - {String|Function(ctx)} origin `Access-Control-Allow-Origin`, default is request Origin header\n```\n它的意思就是默认值就是**请求头的 origin**, 这里的 origin 可不是上面的, 这是在请求服务器的时候, 我们请求的路径\n\n>举个简单的例子: 我们想在百度搜索 react 的使用, 于是我们在搜索框输入回车, 这时候我们的请求就到百度的服务器上, 然后百度在请求头中就可以看到 origin 是我们现在使用的电脑的 ip 地址\n\n## 回忆过去\n\n我以前在学习跨域的时候, 那时候老师给我们教过一个设置跨域的方法, 就是把请求头的 origin 的地址写在 跨域请求里, 那么任何一个地址都可以访问我们的服务器了, 就像这样(伪代码)\n```js\n$Origin = 请求头的 Origin \nAccess-Control-Allow-Origin: $Origin\n```\n## 回到现在继续解决\n我看默认就是 origin 于是我就改成了这样\n\n```js\nconfig.cors = {\n    origin: \'\',\n    credentials: true,\n    allowMethods: \'GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS\'\n}\n```\n然后果然前台后台都能成功的访问`blog-server`端并且拿到数据\n\n这时候我就要夸夸我自己了, 真是个小机灵鬼, 哈哈\n\n.......完\n\n\n\n\n\n\n\n\n\n\n\n','解决本博客前台, 中台, 后台的跨域问题思路',1593360000,1071),(0,23,1,'博客图床功能','## 生存还是毁灭\n转眼七月份了, 我也即将步入大四的脚步, 过几个月就开始秋招了, 想着早点准备的话对找到自己想要的工作很有必要, 所以昨天早上起来就想开始刷算法题了, 但是这时候就想做笔记在哪里做, 因为刚好做了个博客, 而且有后台管理系统, 所以就想在这个博客上写笔记吧\n\n但是这个博客唯一的不足就是引入图片需要在线链接, 我去用了下图床, 再写在 markdown 上, 确实解决了问题\n\n但是这时候我突然冒出一个想法, 我为什么不自己做一个图床给我的博客用呢\n\n所以我在生存还是毁灭直接选择了毁灭, 因为我从来没做过类似的功能, 所以对我来说是一个挑战\n\n## 实现前端\n\n### 实现 input 样式美化\n\n因为图床功能只在后台管理系统上有效, 并且需要权限, 所以我直接在添加文章的页面添加了上传功能\n\n说起这个功能很巧妙, 因为原生样式很难看, 所以我想用 antd 的按钮盖住 input 框, 这个功能很简单也实用\n\nhtml代码如下:\n```html\n<span className=\"upload-image\">\n      <Button size=\"large\">上传图片</Button>\n      <input type=\"file\" title=\"\" onChange={uploadImage}/>\n</span>\n```\ncss代码如下:\n```css\n.upload-image {\n  position: relative;\n}\n.upload-image button {\n  z-index: 0;\n}\n.upload-image input {\n  position: absolute;\n  width: 96px;\n  height: 40px;\n  top: -11px;\n  left: 0;\n  z-index: 1;\n  opacity: 0;\n}\n```\n就是把 button 按钮放在 input 底下, 然后把 input 的透明度变成 0, 这样就实现了点击可以上传图片功能\n\n### 使用 ajax 传给后台\n这里我没有使用原生 ajax,, 而是使用 axios, 它底层封装了 ajax 而且支持 Promise, 很方便就可以提交 ajax 数据给后台\n ```js\nconst uploadImage = (e) => {\n    const file = e.target.files[0]\n    const formData = new FormData()\n    formData.append(\'image\', file)\n    axios({\n      url: servicePath.uploadImage,\n      method: \'post\',\n      data: formData\n    })\n      .then(data => {\n        if (data.data.message === \'添加成功\') {\n          const input = document.getElementById(\'input\')\n          input.value = `![](${data.data.data})`\n          input.select()\n          document.execCommand(\'copy\');\n          message.success(\'添加成功并且复制\')\n        } else {\n          message.error(\'添加失败\')\n        }\n      })\n      .catch(err => {\n        message.error(\'添加失败\')\n      })\n  }\n```\n代码同时在上传成功后也实现了自动复制功能, 这个功能我是第一次做, 以前还真不知道这个 api, 真的是实践出真知啊\n\n**使用这个 api 注意两个点:**\n \n1. 实现复制功能必须选择的是 input 框才可以\n2. input 框可以设置为透明, 但是不能设置为 display: none; (自己走过的坑)\n\n## 实现后端\n### 后端接收数据\n我用的后端是 eggjs\n代码如下:\n```js\n async uploadImage() {\n        const formData = this.ctx.request.files[0]\n        const file = fs.readFileSync(formData.filepath)\n        const pathName = `blog${Date.now()}.${formData.mimeType.split(\'/\')[1]}`\n        fs.writeFileSync(path.join(\'C:/Users/86183/Desktop/meng-blog/server/app/public\', pathName), file)\n        const onLineUrl = `http://127.0.0.1:7001/public/${pathName}`\n        const result = await this.app.mysql.insert(\'image\', { path: onLineUrl })\n        if (result.affectedRows === 1) {\n            this.ctx.body = { message: \'添加成功\', data: onLineUrl }\n        } else {\n            this.ctx.body = { message: \'添加失败\' }\n        }\n    }\n```\n上传成功后保存在 public 上(踩过坑), 就可以通过 http://127.0.0.1:7001/public/blogxxxxxx.png 来访问了\n\n**必须在 public 来访问, 因为 public 里存放的是静态资源**\n\n当然这还没完, 还得配置好路径, 前后端都得配置, 最后才能访问成功\n\n## 优化功能\n\n### 管理页面制作\n仅仅做一个上传功能当然还是不够的, 还得把数据存在数据库, 然后在通过数据库读出来渲染到前端\n\n给大家看一下我的渲染结构\n\n![图片管理部分页面](http://121.199.1.64:7001/public/blog1593591939176.png)\n\n可以实现预览, 复制, 删除功能\n\n### 图片上传压缩\n\n因为有时候图片上传会很大, 这样不容易在页面好好的展示\n所以我加入了图片按比例缩放的功能\n\n具体代码如下:\n```js\nconst changeImageSize = (file, fileType) => {\n    const reader = new FileReader()\n    reader.onload = (readerEvent) => {\n      const image = new Image()\n      image.onload = () => {\n        const canvas = document.createElement(\'canvas\')\n        const max_size = 500;\n        let {width, height} = image\n        if (width > height) {\n          if (width > max_size) {\n            height *= max_size / width;\n            width = max_size;\n          }\n        } else {\n          if (height > max_size) {\n            width *= max_size / height;\n            height = max_size;\n          }\n        }\n        canvas.width = width;\n        canvas.height = height;\n        canvas.getContext(\'2d\').drawImage(image, 0, 0, width, height);\n        const dataUrl = canvas.toDataURL(fileType);\n        axios({\n          url: servicePath.uploadImage,\n          method: \'post\',\n          data: {dataUrl}\n        })\n          .then(data => {\n            if (data.data.message === \'添加成功\') {\n              const input = document.getElementById(\'input\')\n              input.value = `![](${data.data.data})`\n              input.select()\n              document.execCommand(\'copy\');\n              message.success(\'添加成功并且复制\')\n            } else {\n              message.error(\'添加失败\')\n            }\n          })\n          .catch(err => {\n            message.error(\'添加失败\')\n          })\n      }\n      image.src = readerEvent.target.result;\n    }\n    reader.readAsDataURL(file);\n  }\n```\n这个图片压缩功能我也没做过, 全是文件型的 api, 做这么一个简单的图床功能我确实学到了很多, 压缩功能具体是由 canvas 来实现的, 不过经过处理的图片是 base64 转码的, 和我以前上传图片不一样的格式, 所以后台就得改一下\n\n后台简单来说就是把 base64 的字符串从请求体的 body 切出来, 然后存到目录里, 然后在由数据库把图片地址存下, 就大功告成了\n\n我超棒, 哈哈, 夸一下自己, 用了两天就做出来一个简易图床, 虽然在大神眼里不算什么, 但是在我的体验来说我已经很棒了, 能自己动手去完成一个简单功能, 主要在制作的过程中踩过很多坑, 查了很多资料, 最后终于大公告成\n\n最后贴一张图: 地址当然是我的域名地址哈\n\n![](http://121.199.1.64:7001/public/blog1593593017917.jpeg)\n\n这个图是我喜欢的一个乐队 pink floyd 的一个专辑, 迷幻摇滚创始人, 感兴趣的人可以去了解一下, 歌很棒\n\n\n','一张图片引发的血案',1593532800,1039),(0,24,4,'七月博客第一篇日记','今天完善了一天的博客, 天气也不怎么好, 就没出门, 一会出去放松放松, 我现在撸代码的速度越来越快了, 哈哈, 思维也完善了许多, 付出有回报啊\n\n一会把域名备案了, 就可以用域名访问了, 怎么办, 现在好想吃米线, 可是张宝宝不在我身边, 想念我的张宝宝\n\n附上一张我们宝宝的美照 ^_^\n\n![张宝宝美照](http://121.199.1.64:7001/public/blog1593599091557.jpeg)\n','尝试着去试错, 对的机会才更大',1593532800,1099),(0,26,1,'每日leetcode','## 20.有效的括号\n\n[传送门](https://leetcode-cn.com/problems/valid-parentheses/)\n\n今天开始正式刷 leetcode 算法了, 先从热门题开始刷, 刷的越多, 经验越多, 套路知道的越多, 代码当然也会写的更完美\n\n这一题直接把我卡住, 看了官方解答, 时间复杂度 O(n)\n\n**因为我是前端, 所以一切算法题都会用 javascript 来实现, 前端也要学习算法的, 现在前端的通病就是不学习算法, 还有不用单元测试, 这样的习惯很不好, 所以改变前端人人有责, 从我做起, 算法天天要来几题**\n\n不多说了, 直接上代码\n```js\nconst isValid = (s) => {\n    if(s.length === 0){\n        return true\n    }else if(s.length === 1){\n        return false\n    }\n\n    const map = new Map()\n    map.set(\')\',\'(\')\n    map.set(\']\',\'[\')\n    map.set(\'}\',\'{\')\n    const array = []\n\n    for(let i=0;i<s.length;i++){\n        const c = s[i]\n        if(map.has(c)){\n            const popC = array.length ? array.pop() : \'#\'\n            if(map.get(c) !== popC) return false\n        }else{\n            array.push(c)\n        }\n    }\n\n    return array.length ? false : true\n};\n```\n\n整个思路大概是这样的:\n \n1. 利用栈这个数据结构, 然后用循环每个字符来实现入栈还是出栈\n2. 把每个匹配的括号存储在 map 里, 利用 map 来进行匹配\n3. 最后判断栈是否为空来返回 false 或者 true\n\n我这里只是在我的理解基础上解释了一下整个解题过程是怎样的\n\n如果你想更深入了解一下具体的解题思路, 请看[leetcode官方](https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/)\n\n## 155.最小栈\n\n[传送门](https://leetcode-cn.com/problems/min-stack/)\n\n这个题的题解确实不难, 就是在 array 的基础上再封装了一层, 唯一的难点就是最小栈的思路, 利用一个主栈和一个存放最小数的辅助栈来完成两个栈同时进行操作, 这样就会保持数据的同步\n\n代码如下:\n```js\nconst MinStack = function() {\n    this.stack = []\n    this.min_stack = [Infinity]\n};\n\nMinStack.prototype.push = function(x) {\n    this.stack.push(x)\n    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length -1],x))\n};\n\nMinStack.prototype.pop = function() {\n    this.stack.pop()\n    this.min_stack.pop()\n};\n\nMinStack.prototype.top = function() {\n    return this.stack[this.stack.length-1]\n};\n\nMinStack.prototype.getMin = function() {\n    return this.min_stack[this.min_stack.length-1]\n};\n```\n\n## 394.字符串解码\n\n[传送门](https://leetcode-cn.com/problems/decode-string/)\n\n一个中等难度的题目, 基本需求是解析字符串来根据规则生成新的字符串, 考的是栈的应用\n\n解题思路:\n\n1. 先得有两个栈, 存放字符串和数字\n2. 当碰到数字, 那么先存到变量里. 看看下一个还是不是数字, 还是数字的话就拿出变量里的数字乘 10 在加上原来的存到变量中\n3. 当碰到 `[` , 就可以把数字和当时的子串存到栈内\n4. 当碰到 `]` , 就可以把栈内的数字和子串取出来. 加到现在的 str 中\n5. 剩下的情况就直接连加 str \n\n代码如下:\n```js\nconst decodeString = (s) => {\n  let numStack = []\n  let strStack = []\n  let num = 0\n  let str = \'\'\n  for(const char of s){\n      if(!isNaN(char)){\n          num = num * 10 + Number(char)\n      }else if(char === \'[\'){\n          numStack.push(num)\n          num = 0\n          strStack.push(str)\n          str = \'\'\n      }else if(char === \']\'){\n          const repeatTime = numStack.pop()\n          str = strStack.pop() + str.repeat(repeatTime)\n      }else{\n          str += char\n      }\n  }\n  return str\n}\n```\n\n今天目标完成, 三个题刷了一天, 刚开始感觉根本没思路, 希望后面坚持下去有效果, 加油\n\n\n\n','20 题有效的 括号, 155 题最小栈, 394题字符串解码',1593619200,1040),(0,31,1,'刷题知识点总结(更新中)','## 斐波那契数列算法\n首先要明白斐波那契的规律, 以及刚开始的初始值\n法一:\n```js\nfunction fib(n){\n    let top=1,bottom=0,res=0\n    for(let i=0;i<n;i++){\n        res=top+bottom\n        bottom=top\n        top=res\n    }\n    return res\n}\n```\n法二:\n```js\nconst fib = (num) => {\n    const triple = [0, 0, 1];\n    for (let i = 0; i < num; i++) {\n        [triple[0], triple[1], triple[2]] = [triple[1], triple[2], triple[1] + triple[2]];\n    }\n    return triple[2];\n};\n```\n## addEventListener 应用\n\n1. 事件捕获, 从 dom 根节点到最精确的元素节点\n2. 事件冒泡, 从 最精确的元素节点到 dom 根节点\n\naddEventListener 函数参数 type, callback, useCapture\n- type: 事件类型\n- callback: 事件回调\n- useCapture: true 表示捕获触发, false 表示冒泡触发\n\n## 其他\n\n- Linux 的操作系统的 Cron 服务用于管理打印子系统\n- 永久重定向, 301\n- git 回复上一状态: git reset --soft HEAD \n\n\n## 20200705\n\n### 块级元素包裹规则\n\n- 块级元素可以包含内联元素和某些块级元素, 但内联元素不能包含块级元素, 他只能包含其他内联元素\n- 块级元素不能放在 p 里面\n- 有几个特殊的块级元素只能包含内联元素, 不能包含块级元素, 如 h1~h6\n- li 可以包含 div\n- a 标签可以包含任何元素, 除了自身\n\n### Canvas 性能优化\n\n- 将渲染阶段的开销转嫁到计算机阶段之上\n- 使用多个分层的 Canvas 绘制复杂场景\n- 不要频繁设置绘图上下文的 font 属性\n- 不要在动画中使用 putImageData 方法\n- 通过计算和判断, 避免无谓的绘制操作\n- 将固定的内容预先绘制在离屏幕 Canvas 上以提高性能\n- 使用 Worker 和拆分任务的方法避免复杂算法阻塞动画运行\n\n\n### 关于元素内文字换行\n\n- 不换行也不省略\n```css\nword-break: keep-all;\nwhite-space: nowrap;\n```\n- 不换行, 超出用省略号替代\n```css\nword-break: keep-all;\nwhite-space: nowrap;\noverflow: hidden;\ntext-overflow: ellipsis;\n```\n\n### 关于清除浮动\n\n- 父级 div 定义 height\n- 结尾处加空 div 标签 clear:both\n- 父级 div 定义味蕾: after 和 zoom\n- 父级 div 定义 overflow: hidden\n- 父级 div 也浮动, 需要自定义宽度\n- 结尾处加 br 标签, clear : both \n\n### 关于模块化规范\n\n- ES6 Module 规范: JS 标准模块化规范, import 和 export, 官方\n- CommonJS 规范: 用于服务端, nodejs 采用\n- AMD: 异步模块定义规范, 浏览器端, 代表是闲者 RequireJS\n\n### Cookie 不设置 expires 会怎么办\n\n该 Cookie 会在浏览器会话结束时失效\n\n### 关于 const\nconst 实际上保证的并不是变量的值不得改动, 而是变量指向那个内存地址不得改动, 对于简单类型的数据而言, const 声明就相当于常量, const 只能保证指针固定, 但是指向的数据结构是不是可变的不能控制\n','斐波那契数列算法, 很简单',1593792000,1063),(0,32,1,'排序算法','## 排序算法简介\n### 排序算法分类\n\n- 比较类排序: 通过比较来决定元素间的相对次序, 非线性时间排序\n- 不通过比较来决定次序, 可以突破比较排序的时间下限, 线性时间排序\n\n![排序分类](http://121.199.1.64:7001/public/blog1593918355018.png)\n\n### 算法复杂度\n\n|  排序方法   | 时间复杂度(平均)  | 时间复杂度(最坏) | 时间复杂度(最好) | 空间复杂度 | 稳定性 |\n|  ----  | ----  |  ----  | ----  |  ----  | ----  |\n| 插入排序  | O(n^2) | O(n^2) | O(n) | O(1) | 稳定|\n| 希尔排序  | O(n^1.3) | O(n^2) | O(n) | O(1) | 不稳定|\n| 选择排序  | O(n^2) | O(n^2) | O(n^2) | O(1) | 不稳定|\n| 堆排序  | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(1) | 不稳定|\n| 冒泡排序  | O(n^2) | O(n^2) | O(n) | O(1) | 稳定|\n| 快速排序  | O(nlog2n) | O(n^2) | O(nlog2n) | O(nlog2n) | 不稳定|\n| 归并排序  | O(nlog2n) | O(nlog2n) | O(nlog2n) | O(n) | 稳定|\n| 计数排序  | O(n+k) | O(n+k) | O(n+k) | O(n+k) | 稳定|\n| 橘排序  | O(n+k) | O(n^2) | O(n) | O(n+k) | 稳定|\n| 基数排序  | O(n*k)  | O(n*k)  | O(n*k) | O(n+k)| 稳定|\n\n- 稳定: 两数相等, 排序之后顺序没有改变, 就为稳定\n- 不稳定: 两数相等, 排序之后顺序发生变化, 就为不稳定\n- 时间复杂度: 对排序数据的总的操作次数, 反映当 n 变化时, 操作次数呈现什么样的规律\n- 空间复杂度: 算法在计算机里执行所需存储空间的度量\n\n## 冒泡排序\n\n>从第一个元素开始, 两两比较, 如果前面比后面大, 则换位置\n\n```js\nconst bubbleSort2 = arr => {\n  // 一共比 arr.length - 1 次\n  let flag = false\n  for (let i = 0; i < arr.length - 1; i++) {\n    // 每次比较都会最后一个元素为最大元素, 所以可以除去最后那个元素比较\n    for (let j = 0; j < arr.length - 1 - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        flag = true\n        let temp = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = temp\n      }\n    }\n    // 如果这一趟排序没有改变那么就退出循环, 不用排序了\n    if (flag) flag = false\n    else break\n  }\n  return arr\n}\n```\n\n## 选择排序\n\n>首先在未排序的数组中找出最小或最大的元素, 放在数组起始位置, 然后再从剩余的元素中找出最小或最大的元素, 放在已排序的序列末尾\n\n```js\nconst selectSort = arr => {\n  // 一共排 arr.length - 1 趟\n  for (let i = 0; i < arr.length - 1; i++) {\n    // 设置一个最小索引\n    let minIndex = i\n    for (let j = i + 1; j < arr.length; j++) {\n      // j 从 i + 1 开始寻找\n      if (arr[minIndex] > arr[j]) {\n        // 当最小值大于 arr[j] , 那么把 j 索引给了 minIndex\n        minIndex = j\n      }\n    }\n    // 如果最小索引变化, 才交换, 否则不用交换\n    if (minIndex !== i) { // 优化点\n      let temp = arr[i]\n      arr[i] = arr[minIndex]\n      arr[minIndex] = temp\n    }\n  }\n  return arr\n}\n```\n\n复杂在何时都是 O(n^2), 不会额外占用内存空间\n\n## 插入排序\n\n```js\nconst insertSort = arr => {\n  // i = 1 假设 arr[0] 为有序数组\n  for (let i = 1; i < arr.length; i++) {\n    // 设置插入值\n    let insertVal = arr[i]\n    // 设置插入到的插入索引\n    let insertIndex = i - 1\n    // 当没有遍历完有序数组而且当前插入值小于插入数组的数\n    while (insertIndex >= 0 && insertVal < arr[insertIndex]) {\n      // 如果小于, 那么就后移一位\n      arr[insertIndex + 1] = arr[insertIndex]\n      // 然后继续遍历看看下一位是否符合条件\n      insertIndex--\n    }\n    // 当循环完成, 找到待插入的位置 insertIndex + 1, 插入数据\n    if (insertIndex + 1 !== i) arr[insertIndex + 1] = insertVal\n  }\n  return arr\n}\n```\n\n## 希尔排序\n\n```js\nconst shellSort2 = arr => {\n  for (let gap = Math.floor(arr.length / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (let i = gap; i < arr.length; i++) {\n      let j = i\n      // 要插入的值\n      let temp = arr[j]\n      if (arr[j] < arr[j - gap]) {\n        // 简单插入排序的套路, 如果前面还有数, 而且前面的数比当前数小, 进入循环交换\n        while (j - gap >= 0 && temp < arr[j - gap]) {\n          arr[j] = arr[j - gap]\n          j -= gap\n        }\n        // 交换完了就把当前值给了换完的 arr[j]\n        arr[j] = temp\n      }\n    }\n  }\n  return arr\n}\n```\n\n## 快速排序\n\n```js\nconst quickSort =  arr => {\n  if(arr.length <= 1) return arr\n  let pivotIndex = Math.floor(arr.length / 2) \n  let pivot = arr.splice(pivotIndex,1)[0]\n  let left = [], right = []\n  for(let i=0;i<arr.length;i++){\n    if(arr[i] < pivot){\n      left.push(arr[i]) \n    }else{\n      right.push(arr[i]) \n    }\n  }\n  return [...quickSort(left),pivot,...quickSort(right)]\n}\n```\n\n## 归并排序\n\n```js\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr\n  let middle = Math.floor(arr.length / 2)\n  let left = arr.slice(0, middle)\n  let right = arr.slice(middle)\n  return merge(mergeSort(left), mergeSort(right))\n}\n\nfunction merge(left, right) {\n  let result = []\n  while (left.length && right.length) {\n    if (left[0] <= right[0]) {\n      result.push(left.shift())\n    } else {\n      result.push(right.shift())\n    }\n  }\n  while (left.length) result.push(left.shift())\n  while (right.length) result.push(right.shift())\n  return result\n}\n```\n\n## 基数排序\n\n```js\nconst radixSort = (arr, max) => {\n  let dev = 1\n  let mod = 10\n  let counter = []\n  for (let i = 0; i < max; i++, mod *= 10, dev *= 10) {\n    for (let j = 0; j < arr.length; j++) {\n      let bucket = Math.floor((arr[j] % mod) / dev)\n      if (counter[bucket] === undefined) {\n        counter[bucket] = []\n      }\n      counter[bucket].push(arr[j])\n    }\n\n    let pos = 0\n    for (let j = 0; j < counter.length; j++) {\n      if (counter[j] !== undefined) {\n        while (counter[j].length) {\n          arr[pos++] = counter[j].shift()\n        }\n      }\n    }\n  }\n  return arr\n}\n```\n\n\n\n','复习排序算法',1593878400,1072),(0,33,1,'leetcode 94.二叉树的中序遍历','## 二叉树\n\n二叉树是一种特殊的树结构, 每个节点最多有两个, 遍历出二叉树的方法有三种\n\n1. 中序遍历: 最常用, 左根右的遍历顺序\n2. 先序遍历: 根左右的遍历顺序\n3. 后序遍历: 左右根的遍历顺序\n\n这道题是实现二叉树的中序遍历, 有好几种方式\n\n##  递归算法实现\n\n如果当前阶段存在那么就继续调用函数去遍历它的左右节点, 否则就返回空数组\n\n```js\nconst inorderTraversal = (root) => {\n    if(root){\n        return [...inorderTraversal(root.left),root.val,...inorderTraversal(root.right)]\n    }\n    return []\n};\n```\n\n## 基于栈的遍历实现\n\n如果当前的节点不为空, 那么就往栈里添加当前节点, 然后当前节点就为左节点, 知道左节点没有了, 就从栈里提取一个节点, 然后把这个节点的值存到结果数组中, 然后当前节点等于右节点. 继续找左节点直到没有, 然后继续提取栈顶的节点. 拿出值添加到数组中\n\n```js\nconst inorderTraversal = (root) => {\n  let result= []\n  let stack= []\n  while(root!==null || stack.length){\n      while(root !== null){\n          stack.push(root)\n          root = root.left\n      }\n      root = stack.pop()\n      result.push(root.val)\n      root = root.right\n  }\n  return result\n};\n```\n\n二叉树是一个很重要的数据结构, 它既集合了数组的优点, 也结合了链表的快速查找添加优点, 很是方便\n','二叉树的中序遍历javascript实现',1593878400,1052),(0,34,4,'好好学习数据结构和算法','通过这几天的刷题, 深深明白数据结构和算法的重要性, 他们两的关系就想天与地, 阴与阳, 互相不能分开, 光学数据结构没地方用, 但是只看算法不懂数据结构也没有基础思路, 以前很怕算法, 但是真真开始的时候还是感觉很有意思, 一个题有好几种解法, leetcode 还贴心的给出了执行时间和内存消耗, 让解题不在枯燥, 而且强大的社区给了很多种解题的方案\n\n人多力量大, 看到这么多小伙伴和自己一起分享心得, 自己提升也快, 加油','数据结构和算法真的是很重要',1593878400,1095),(0,35,3,'Supermarket Flowers','[传送门](http://music.163.com/song?id=460043710&userid=312009869)\n\n这首歌是黄老板为去世的姥姥写的, 当时他正在飞机上听到姥姥去世的消息, 哈利路亚, 祝福在天国的姥姥, 这首歌也在我最低落的时候陪了我好长时间, 黄老板的声音很温柔, 唱的让人柔情万丈,\n\n这里贴一段歌词:\n\n```css\nSo I\'ll sing Hallelujah\n所以我轻吟祈祷着 哈利路亚\nYou were an angel in the shape of my mum\n你就是位形神皆似妈妈的天使啊\nWhen I fell down you\'d be there holding me up\n每当我落入低谷 都有你陪伴守护\nSpread your wings as you go\n爱的羽翼展开遍布你所到之处\nAnd when God takes you back we\'ll say Hallelujah\n当上帝将你带走 我们亦安慰念起 哈利路亚\nYou\'re home\n你终于到家啦\n```\n哈利路亚, 我们都是温柔的人','黄老板的一首抒情歌, 每次听到都很暖心',1593878400,1015),(0,36,1,'利用栈实现进制转换','## 算法：实现36进制转换\n\n在刷字节面经的时候有这样一个题, 今天在学数据结构的时候碰巧遇上了这个题, 所以我来实现一下这个算法\n\n十进制转各种进制的规律都是一样的, **利用取余法**\n\n举个例子: \n\n>33 转 32 进制, 利用取余法, 33 / 32 商 1 余 1 , 然后在用商 1 取余 32 , 商 1 余 1 , 至此完成, 然后根据余数从后往前取, 得出结果 33 转 32 进制结果为 11\n\n如果还是担心结果不对, 可以反推一下, 利用 32 进制的 11 转为十进制, 其他进制转 十进制, 利用从高位开始, 第一位 乘 32 的 0 次方, 第二位乘 32 的 1 次方, 依次知道没有数据\n\n1 * 32^0 + 1 \\* 32^1 = 33 所以推理正确, 接下来用栈来实现这个转换方法\n```js\nconst Convert = (num, base) => {\n  let stack = []\n  do{\n     stack.push(num % base)\n     num = Math.floor(num / base)\n  } while(num > 0)\n  let result = \'\'\n  while(stack.length > 0){\n     result += stack.pop()\n  }\n  return result\n}\n```\n\n传入十进制数 num 和 转换的进制 base, 利用 do while 的循环是因为在 num <= 0 的时候会多执行一次, 也就是把最后的余数会 push 到栈中, 如果先判断的话那么最后一次的余数就不会加入栈中 ,导致结果错误\n\n那么下面的 while 循环判断当栈的长度是固定的正整数,  当栈长度为 0 的时候就应该结束循环, 这样结果就出来了\n\n 当然这个算法只是实现了十进制转其他进制,  那么二进制转其他, 八进制转其他. 都可以当做一个算法来实现, 有兴趣的可以尝试一下','栈是一种很有效率的结构',1594051200,1051),(0,37,3,'Dealbreaker  ','[传送门](http://music.163.com/song?id=18733268&userid=312009869)\n\n这首歌的歌手叫 Rachael Yamagata,她的中文名叫山形瑞秋, 这个名字很古怪吧, 我第一次听也很差异, 怎么还会有人取这种名字\n\n不过我在听她的这首歌时, 喜欢上了这个歌手, 她的风格是很恬静的, 就像你躺在树荫下风吹拂着你的脸庞, 那么惬意, 慵懒, 就算你什么都不干躺一整天都可以\n\n贴一段歌词:\n\n```css\nWithout you.\n当我无你陪伴\nI packed up the car,\n我重整了车\nAnd started to drive.\n然后启动\nWithout a plan, with no direction.\n没有计划，也没有方向\nYou said it\'d be good for me,\n你说过这样会对我有帮助\nTo break out of my daily routine.\n去突破那些常规\nYou were always trying to teach some lesson.\n你总那么喜爱说教\n```\n\n如果你想对你曾经的任性对你的爱人道歉, 用这首歌挺合适的, 歌词正中人心\n','山形瑞秋的歌总是让人能安静下来',1594051200,1097),(0,38,1,'leetcode 15.三数之和','## 解题\n\n[传送门](https://leetcode-cn.com/problems/3sum/)\n\n作为经典的算法题, 无论两数之和还是三数之和都是面试常考\n\n整个题的难度比两数之和上升了一个档次, 要避免元素重用, 还要三个数加起来的和为 0, 而且答案可以为多个结果\n\n> 参考了大神的解题过程感觉自己活着就是浪费空气, 大神的算法写的太优美了, 于是自己总结了思路, 在博客里做一下笔记\n\n\n1. 先把数组排序\n2. 选出一个固定的值 nums\\[i], 然后利用双指针 L 和 R 指向固定值的后面序列两端\n3. 三数之和为 nums\\[i] + nums\\[L] + nums\\[R]\n4. 如果 nums\\[i] 的值大于 0, 那么和就不可能等于 0\n5. 如果 nums\\[L] 和 nums\\[L+1] 的值相等, 那么 L++ 实现去重, 同理用在 R 指针上\n6. 如果 在第二次循环以后 nums[i] 大于 nums\\[i+1] 时, 跳出循环执行下一次, 也实现去重\n7. 如果和为 0, 把三个数放到结果集中, 如果和小于 0, 那么 L++, 如果和大于 0, 那么 R--\n\n代码如下\n\n```js\nconst threeSum = function(nums) {\n    let len = nums.length\n    let res = []\n    if(len < 3 || nums === null) return res\n    nums.sort((a,b)=>a-b)\n    for(let i=0;i<len;i++){\n        if(nums[i] > 0) break\n        if(i > 0 && nums[i] === nums[i-1]) continue\n        let L = i + 1\n        let R = len - 1\n        while(L<R){\n            let sum = nums[i] + nums[L] + nums[R]\n            if(sum === 0){\n                res.push([nums[i],nums[L],nums[R]])\n                while(L<R && nums[L] === nums[L+1]) L++\n                while(L<R && nums[R] === nums[R-1]) R--\n                L++\n                R--\n            }\n            else if(sum<0) L++\n            else if(sum>0) R--\n        }\n    }\n    return res\n};\n```\n\n这个代码没有耗费半点笔墨, 实现了三数之和的算法, 代码也很通俗易懂, 有兴趣的小伙伴去试一下\n\n\n','基于两数之和的变体',1594224000,1085),(0,40,1,'leetcode 2.两数相加','## 题解\n\n[传送门](https://leetcode-cn.com/problems/add-two-numbers/)\n\n今天来做一下经典的两数相加\n\n链表的运用是必须掌握的，整体思路这这样\n\n1. 先生成一个新链表\n2. 然后在定义两个变量 n1, n2, 分别存储 l1 和 l2 链表取出的值\n3. 定义 n 作为两数相加后是否进位，利用余数来判断，初始值为 0\n4. 定义 sum 作为相加结果存储，然后放到链表内\n5. 一直到 l1 里的元素不存在，或者 l2 里的节点不存在后跳出循环\n6. 这时候判断 n 是否为 0，不为 0 的话向链表结果里在添加一个节点\n7. 返回链表\n\n\n代码如下:\n```js\nconst addTwoNumbers = function(l1, l2) {\n   let node = new ListNode(\'head\')\n   let temp = node, sum, n = 0\n   while(l1 || l2){\n       const n1 = l1 ? l1.val : 0\n       const n2 = l2 ? l2.val : 0\n       const sum = n1 + n2 + n\n       temp.next = new ListNode(sum % 10)\n       temp = temp.next\n       n = parseInt(sum / 10)\n       if(l1) l1 = l1.next\n       if(l2) l2 = l2.next\n   }\n   if(n !== 0){\n       temp.next = new ListNode(n)\n   }\n   return node.next\n};\n```\n这个思路和官方解释使用哑节点差不多，执行时间和耗费内存都差不多\n','利用链表实现两数相加',1594569600,1092),(0,41,4,'备案','现在可以用 [mengxiangyu.top](http://www.mengxiangyu.top/) 来访问我的网站了, 我终于也是有自己的个人博客的人了, 开心^_^\n\n这几天学习的心思一直放不下来, 可能到了厌烦期, 学习的效率和内容都没有以前好, 可能是夏天燥热的过, 希望快快调整回来, 准备充分, 准备迎接金九银十, 加油','网站终于备案成功',1594656000,1019),(0,42,1,'稀疏数组','## 稀疏数组\n\n在一个数组中大部分元素为 0, 或者为同一个数值时, 可以用稀疏数组来存放数据, 简单来说就把原来二维数组中的数据作为一个映射\n\n## 例子\n\n有一个棋盘, 黑子为 1, 白子为 2, 下到一半突然想存盘, 如下图\n\n![棋盘](http://121.199.1.64:7001/public/blog1595325129312.jpeg)\n\n棋盘上有子的可以按这个子的行列来存, 但是棋盘上没有子的格子数据全是 0, 如果都存下的话很浪费空间\n\n于是就可以用稀疏数组来存下对应的数据, 它的数据格式是这样\n\n```js\nconst sparseArr = [\n[\'总行数\',\'总列数\',\'总子数\'],\n[\'一个子所在的行\',\'一个子所在的列\',\'黑子1\'],\n[\'一个子所在的行\',\'一个子所在的列\',\'白子2\'],\n]\n```\n\n这样仅用一个简单的二维数组就存下了整个棋盘和上面子的对应状态\n\n而且根据这个稀疏数组还可以还原为原来的棋盘\n\n具体代码如下:\n\n```js\n// 创建空棋盘\nlet arr = []\nfor(let i=0;i<11;i++){\n	arr[i] = []\n	for(let j=0;j<11;j++){\n		arr[i].push(0)\n	}\n}\n\n// 把棋盘的第二行和第三列数据改为 1(黑子)\n// 把棋盘的第三行和第四列数据改为 2(白子)\n\narr[1][2] = 1\narr[2][3] = 2\n\n// 得出总子数 sum\nlet sum = 0\nfor(let i=0;i<11;i++){\n	for(let j=0;j<11;j++){\n		if(arr[i][j] !== 0){\n			sum++\n		}\n	}\n}\n\n// 利用总子数来创建稀疏数组\nlet sparseArr = []\nfor(let i=0;i<sum+1;i++){\n	sparseArr[i] = []\n}\nsparseArr[0][0] = 11\nsparseArr[0][1] = 11\nsparseArr[0][2] = sum\n\n// 把每行和每列存在的数据存到稀疏数组中\nlet count = 0\nfor(let i=0;i<11;i++){\n	for(let j=0;j<11;j++){\n		if(arr[i][j] !== 0){\n			count++\n			sparseArr[count][0] = i\n			sparseArr[count][1] = j\n			sparseArr[count][2] = arr[i][j]\n		}\n	}\n}\n\n// 再从稀疏数组中读取数据并且重新存放到新的棋盘中\nlet row = sparseArr[0][0] \nlet col = sparseArr[0][1]\nlet newArr = []\nfor(let i=0;i<row;i++){\n	newArr[i] = []\n	for(let j=0;j<col;j++){\n		newArr[i].push(0)\n	}\n}\nfor(let i=1;i<sparseArr.length;i++){\n	newArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]\n}\n\n```\n\n看到这相信你已经学会了怎样使用稀疏数组, 接下来我还有很多关于数据结构与算法的文章发布, 敬请期待','利用稀疏数组来做存储棋盘功能',1595260800,1049),(0,43,1,'队列','## 队列\n\n队列是一个有序列表, 可以通过数组和链表实现\n\n## 数组实现队列\n\n参数介绍:\n\n- maxsize: 队列容纳最大元素数\n- rear: 最后一个元素索引, 加入在后\n- front: 第一个元素索引, 取出在前, 指向对头的前一个\n\n![数组队列](http://121.199.1.64:7001/public/blog1595393836272.png)\n\n实现代码:\n\n```js\n/*\n创建队列 queueData\n判断队列为空 isEmpty\n判断对列为满 isFull\n加入元素 addElement\n取出元素 getElement\n显示所有元素 showQueue\n显示头元素 showHead\n*/\nfunction queue(maxSize){\n	this.maxSize = maxSize\n	this.queueData = new Array(maxSize)\n	this.front = -1\n	this.rear = -1\n	this.isFull = isFull\n	this.isEmpty = isEmpty\n	this.addElement = addElement\n	this.getElement = getElement\n	this.showQueue = showQueue\n	this.showHead = showHead\n}\nfunction isFull(){\n	return this.rear === this.maxSize - 1\n}\nfunction isEmpty(){\n	return this.rear === this.front\n}\nfunction addElement(n){\n	console.log(this.rear)\n	if(this.isFull()) return console.log(\'队列已满\')\n	this.rear++\n	this.queueData[this.rear] = n\n}\nfunction getElement(){\n	if(this.isEmpty()) throw new Error(\'队列为空\')\n	this.front++\n	return this.queueData[this.front]\n}\nfunction showQueue(){\n	if(this.isEmpty()) return console.log(\'队列为空\')\n	return this.queueData\n}\nfunction showHead(){\n	if(this.isEmpty()) return console.log(\'队列为空\')\n	return this.queueData[this.front+1]\n}\n```\n\n这样变实现了数组队列的增删改查, 但是有一个 bug, 如上图, 如果取出队头元素, 那么整个数组的索引还是再持续递增, 而不会循环利用, 这样很浪费空间, 而且也不是设计的最优\n\n所以我们就需要来改进为数组循环队列才合适\n\n## 数组循环队列\n\n正所谓循环就是当对头元素被取出或对尾加入元素后, 会循环利用剩余的空间, 而不会递增的新增空间, 类似一个闭环\n\n用循环来设计数组队列的话这几点要注意:\n\n- 利用取余 % 来实现队列索引的循环利用\n- front 永远指向对头, rear 永远指向队尾, 并且他们的初始值都为 0\n- 判断队满公式: (rear + 1) % maxSize === front\n- 判断对空公式: rear === front\n- 求出队列的有效元素个数: (rear + maxSize - front) % maxSize\n\n这里比较绕, 你们可以举个例子在纸上写写就明白为什么要这样做了\n\n具体代码如下:\n\n```js\nfunction queue(maxSize){\n	this.maxSize = maxSize\n	this.queueData = new Array(maxSize)\n	this.front = 0\n	this.rear = 0\n	this.isFull = isFull\n	this.isEmpty = isEmpty\n	this.addElement = addElement\n	this.getElement = getElement\n	this.showQueue = showQueue\n	this.showHead = showHead\n	// 加入求队列元素个数方法\n	this.queueCount = queueCount\n}\nfunction isFull(){\n	return (this.rear + 1) % this.maxSize === this.front\n}\nfunction isEmpty(){\n	return this.rear === this.front\n}\nfunction addElement(n){\n	if(this.isFull()) return console.log(\'队列已满\')\n	// 先在队尾加入元素, 在 +1, 这样保证队尾一直是 rear\n	this.queueData[this.rear] = n\n	this.rear++\n}\nfunction getElement(){\n	if(this.isEmpty()) throw new Error(\'队列为空\')\n	// 先把当前对头的值留下, 然后在让对头 +1, 然后在返回 value, 保证 front 永远是对头\n	const value = this.queueData[this.front]\n	this.front = (this.front + 1) % this.maxSize\n	return value\n}\nfunction showQueue(){\n	if(this.isEmpty()) return console.log(\'队列为空\')\n	// 打印队列的时候先从队头开始, 在遍历对头 + 总个数, 这样展现每个元素\n	for(let i=this.front;i< this.front + this.queueCount();i++){\n		// 因为是循环, 所以 i%maxSize 才是最终的元素索引\n		console.log(`第${i%this.maxSize}个值: ${this.queueData[i%this.maxSize]}`)\n	}\n}\n// 加入求队列元素个数方法\nfunction queueCount(){\n	return (this.rear + this.maxSize - this.front) % this.maxSize \n}\nfunction showHead(){\n	if(this.isEmpty()) return console.log(\'队列为空\')\n	// 直接拿出 front 元素就可\n	return this.queueData[this.front]\n}\n```\n\n强烈建议拷贝代码去自己尝试一下, 光看是很难理解其中的道理的\n\n今天的数据结构就介绍到这里, 链表来表示队列的方法等后面更新链表结构后会加入\n\n\n\n','利用数组和链表实现队列',1595347200,1049),(0,44,3,'Creep','[Creep](http://music.163.com/song?id=22605222&userid=312009869)\n\n这首歌是一支来自英国牛津的乐队 RadioHead 的歌, 这个乐队被翻译过来叫电台司令, 我刚开始听到这个乐队的时候感觉很好笑, 电台的司令, 这是我前乐队 bass 手给我推荐的\n\n别看他名字搞笑, 但是歌可是很棒的, 感兴趣的去听听, 对了, 这首歌还曾在抖音上火过一段时间, 不过是翻唱版本\n\n整个歌表达的就是暗恋的唯唯诺诺, 最后也不敢表白的舔狗故事\n\n贴一段歌词\n\n```css\nYou\'re just like an angel\n你就像天使一样纯洁\nYour skin makes me cry\n你的一切令我动容\nYou float like a feather\n你就像羽毛一样轻盈\nIn a beautiful world\n飘浮在美丽的世界里\nAnd I wish I was special\n多希望我也是特别的\nYou\'re so ******\' special\n因为你如此与众不同\nBut I\'m a creep, I\'m a weirdo.\n但我却是如此卑劣 我是一个怪胎\nWhat the hell am I doing here?\n我不知道自己在这里做什么\nI don\'t belong here.\n我根本不属于这里\nI don\'t care if it hurts\n我不在乎是否受伤\nI want to have control\n我只想保持冷静\nI want a perfect body\n我想要一个完美的外表\nI want a perfect soul\n我想要一个完美的灵魂\nI want you to notice\n多希望你能注意到\nWhen I\'m not around\n```\n\n','一首舔狗的歌',1595347200,1093),(0,45,1,'单链表','## 链表\n\n今天来介绍一下链表, 这个数据结构是最常用的结构之一, 它的存储方式是链式的, 就想锁链一样, 一个连着一个\n\n像下面这样\n\n![链表结构](http://121.199.1.64:7001/public/blog1595476748460.png)\n\n从链表的开始是一个头节点, 这个节点就是一个开端, 它的右边是值, 左边是指向下一个节点的地址, 也就是 A 节点, A 节点的下一个节点是 B 节点\n\n这种数据结构在处理节点插入, 删除都有很高的效率, 因为只需要找到其指向的地址, 换一下就可以\n\n下面我们用代码实现链表的增删改查\n\n```js\n/*\n节点类 Node\n节点值 val\n节点指向 next\n\n链表类 Linked\n插入节点 add\n显示节点 show\n删除节点 remove\n修改节点 update\n指定节点插入 insert\n判空 isEmpty \n*/\n\nfunction Node(val){\n	this.val = val\n	this.next = null\n}\n\nfunction Linked(){\n	this.head = new Node(\'head\')\n	this.add = add\n	this.show = show\n  this.remove = remove\n	this.insert = insert\n	this.update = update\n	this.isEmpty = isEmpty\n}\n\nfunction add(node){\n  // 利用临时变量来实现遍历\n	let temp = this.head\n	while(true){\n		// 循环找到指向为 null 的节点, 插入到后面\n		if(temp.next === null){\n			temp.next = node\n			break\n		}\n		temp = temp.next\n	}\n}\nfunction show(){\n	this.isEmpty()\n	let temp = this.head.next\n	// 循环打印链表\n	while(true){\n		if(temp === null) break\n		console.log(temp.val)\n		temp = temp.next\n	}\n}\nfunction insert(nodeVal,newNode){\n	this.isEmpty()\n	let temp = this.head.next\n	// 循环链表, 当前节点符合要寻找的节点 nodeVal, 插入, 否则指向下一节点继续寻找\n	while(true){\n		if(temp.val === nodeVal){\n			// 把新节点的 next 指向新节点之前节点的 next\n			newNode.next = temp.next\n			// 再把新节点之前节点的 next 指向新节点的 next\n			temp.next = newNode\n			break\n		}\n		temp = temp.next\n	}\n}\nfunction remove(nodeVal){\n	this.isEmpty()\n	let temp = this.head\n	// 循环链表找到节点, 把要删除的节点的前一节点指向后一节点\n	while(true){\n		if(temp.next.val === nodeVal){\n			temp.next = temp.next.next\n			break\n		}\n		temp = temp.next\n	}\n}\nfunction isEmpty(){\n	 if(this.head.next === null) return console.log(\'链表为空\')\n}\nfunction update(oldNodeVal,newNodeVal){\n	this.isEmpty()\n	let temp = this.head.next\n	// 循环链表, 找到要更新的节点, 更新 val 值\n	while(true){\n		if(temp.val === oldNodeVal){\n			temp.val = newNodeVal\n			break\n		}\n		temp = temp.next\n	}\n}\n```\n\n在代码中我都有注释每个函数的用法, 有疑问可以去看看注释\n\n## 链表常考面试题\n\n### 获取节点数\n\n```js\n/*\n获取节点数\nparams head 一个链表的头结点\nreturn number 长度\n*/\nfunction getLength(head){\n	console.log(head.next)\n	if(head.next === null) return 0\n	let temp = head.next\n	console.log(temp)\n	let length = 0\n	while(temp !== null){\n		length++\n		temp = temp.next\n	}\n	return length\n}\n```\n\n### 获取一个链表的倒数第 K 个节点\n\n思路: \n\n1. 编写一个方法, 接收头结点 head, 倒数的索引  index\n2. 先把链表遍历一遍求出长度\n3. 得到长度后在遍历一遍链表到 (长度 - index) 时候返回节点就是结果\n\n**需要用到上面的 getLength 方法**\n\n```js\n/**\n*遍历单项链表的倒数index节点\n*@params index 倒数第 index\n*@params head 头结点\n*@return 节点\n*/\nfunction getNode(head,index){\n	if(head.next === null) return console.log(\'链表为空\')\n	const length = getLength(head)\n	if(index <= 0 || index > length) return null\n	let temp = head.next\n	for(let i=0;i<length-index;i++){\n		temp = temp.next\n	}\n	return temp\n}\n```\n\n### 反转链表\n\n反转链表的难度会稍微高点, 因为是单链表反转, 所以得想一定的办法\n\n思路: \n\n1. 先定义一个新头结点 reverseHead\n2. 遍历原来的链表, 遍历一个节点, 将其取出加入到新节点 reverseHead 的最前端\n3. 将原来的链表 .next = reverseHead.next 上, 这样便实现了反转\n\n```js\n/**\n*反转数组\n*@params head 链表头结点\n*@return undefined\n*/\nfunction reverseLinked(head){\n	if(head.next === null || head.next.next === null) return console.log(\'链表不需要反转\')\n	let cur = head.next\n	// 建立新头节点\n	let reverseHead = new Node(\'reverseHead\')\n	while(cur !== null){\n	  //这里比较难理解, 大概解释一下\n	  // 因为要取出节点, 所以得把下一节点存下这样才不会丢失\n	  let next = cur.next\n	  // 改变当前节点的 next 指向永远指向新头结点的 next, 为了与原链表断开连接\n	  cur.next = reverseHead.next\n	  // 然后在把新头节点的 next 指向当前节点\n	  reverseHead.next = cur\n	  // 然后把下一节点赋给当前节点\n	  cur = next\n	}\n	head.next = reverseHead.next\n}\n```\n\n我简单画个图来便于理解:\n\n\n![反转链表](http://121.199.1.64:7001/public/blog1595485965778.png)\n\n循环链表, 把每个节点都放到 reverseHead 的 next 上, 如果这样便实现了反转\n\n### 倒序打印链表\n\n一看这个题与上题很相似, 很容易的想到先把链表反转, 然后在循环打印, 但是这样有一个弊端, 就是原链表会改变, 如果想用原链表的话还得反转回去, 这样很麻烦, 所以这种方法不妥\n\n换一种思路: \n\n1. 利用栈后入先出的特性可以实现倒序\n2. 循环链表, 压入栈\n3. 在循环栈在出栈, 这样就实现了倒序输出\n\n具体代码如下:\n\n```js\n/**\n*倒序打印链表\n*@params head 头结点\n*@return undefined\n*/\nfunction reverseConsoleLinked(head){\n	if(head.next === null) return console.log(\'链表为空\')\n	// 创建栈来存储节点\n	let stack = []\n	let temp = head.next\n	while(temp !== null){\n		stack.push(temp)\n		temp = temp.next\n	}\n	while(stack.length !== 0){\n		console.log(stack.pop().val)\n	}\n}\n```\n\n这个逻辑就很简单了, 核心是用到了栈这个数据结构, 在 JS 中可以用数组来模拟栈, 在这里就不详细解释了\n\n到这里单链表就介绍完了, 有兴趣的小伙伴去动手试试本文的代码, 数据结构和算法只看不做是在耍流氓\n\n','单链表的增删改查和一些大厂面试题',1595433600,1010),(0,46,1,'双向链表','## 双向链表\n\n双向链表和单项链表的区别就是前者可以查找当前节点的前一节点和后一节点, 而后者只能查找后一节点\n\n这是因为双向链表比单项链表多了一个 pre 指向前一节点, 如下图\n\n![双向链表](http://121.199.1.64:7001/public/blog1595556395164.png)\n\n双向链表和单向链表的增删改查同理, 只不过多了一个 pre, 在插入或删除的时候要修改 pre 就可以了\n\n代码如下:\n\n```js\n/**\n*Node类\n*@params val 节点值\n*@return \n*/\nfunction Node(val){\n	this.val = val\n	this.next = null // 下一节点\n	this.pre = null // 上一节点\n}\n/**\n*Node类\n*@params \n*@return \n*/\nfunction Linked(){\n  this.head = new Node(\'head\') // 初始化头结点\n  this.isEmpty = isEmpty // 判断是否为空\n  this.add = add // 插入节点\n  this.update = update // 更新节点\n  this.remove = remove // 删除节点\n  this.show = show // 展示节点\n}\nfunction isEmpty(){\n  if(this.head.next === null) return console.log(\'链表为空\')\n}\nfunction add(node,oldNode){\n  let temp = this.head\n  if(arguments.length === 1){ // 在链表最后插入\n    while(true){\n      if(temp.next === null){\n        temp.next = node\n        node.pre = temp\n        break\n      }\n      temp = temp.next\n    }\n  }else if(arguments.length === 2){ // 在链表中间插入\n    while(true){\n      if(temp.val === oldNode){\n	// 核心逻辑, 顺序不能错, 否则会引起循环\n	node.next = temp.next\n	temp.next.pre = node\n	temp.next = node\n	node.pre = temp\n	break\n	}\n	temp = temp.next\n	}	\n    }	\n}\nfunction show(){\n  this.isEmpty()\n  let temp = this.head.next\n  while(temp !== null){\n    console.log(temp.val)\n    temp = temp.next\n  }\n}\nfunction update(oldNode,newNode){\n  this.isEmpty()\n  let temp = this.head.next\n  while(true){\n    if(temp.val === oldNode){\n      temp.val = newNode\n      break\n    }\n    temp = temp.next\n  }\n}\nfunction remove(node){\n  this.isEmpty()\n  let temp = this.head.next\n  while(true){\n    if(temp.val === node){\n      temp.pre.next = temp.next\n      temp.next.pre = temp.pre\n      break\n    }\n    temp = temp.next\n  }\n}\n```\n','双向链表的增删改查',1595520000,1060),(0,47,1,'栈','## 栈\n\n栈的特点是后入先出(LIFO, Last In First Out)\n\nJavaScript 的数组就模拟了栈的方法, 比如说 \n- push() 入栈\n- pop() 出栈\n\n## 栈的应用场景\n\n1. 子程序调用\n2. 处理递归\n3. 表达式转换\n4. 二叉树遍历\n5. 深度优先搜索(DFS)\n\n## 创建栈类\n\n```js\n/**\n * 栈类\n * @param maxSize 栈的最大长度\n * @constructor Stack\n */\nfunction Stack(maxSize){\n  this.maxSize = maxSize\n  this.arr = new Array(maxSize)\n  this.top = -1\n  // 入栈\n  this.push = push\n  // 出栈\n  this.pop = pop\n  // 判空\n  this.isEmpty = isEmpty\n  // 判满\n  this.isFull = isFull\n  // 显示栈\n  this.show = show\n  // 查看栈顶\n  this.peek = peek\n}\nfunction peek(){\n  return this.arr[this.top]\n}\nfunction isFull(){\n  return this.top === this.maxSize - 1\n}\nfunction isEmpty(){\n  return this.top === -1\n}\nfunction push(data){\n  if(this.isFull()) return console.log(\'栈满, 无法加入元素\')\n  this.top++\n  this.arr[this.top] = data\n}\nfunction pop(){\n  if(this.isEmpty()) return console.log(\'栈空, 没有元素\')\n  const value = this.arr[this.top]\n  this.top--\n  return value\n}\nfunction show(){\n  if(this.isEmpty()) return console.log(\'栈空\')\n  while(this.top >= 0){\n    console.log(this.arr[this.top])\n    this.top--\n  }\n}\n```\n\n栈内实现了增删改\n\n## 利用栈实现表达式计算\n\n利用两个栈来分别存储**数字**和**操作符**\n\n具体思路如下:\n\n1. 通过一个 index 值遍历表达式\n2. 如果是一个数字, 直接入数栈\n3. 如果是操作符\n   - 如果当前栈空, 直接入栈\n   - 如果符号栈有操作符, 进行比较, **如果当前操作符的优先级小于或等于栈中的操作符,** 就需要从数栈中取出两个数, 从符号栈中取出一个符号, 进行运算, 得到结果, 入数栈, 然后将当前的操作符入符号栈, **如果当前操作符优先级大于栈中操作符**, 直接入符号栈\n4. 当表达式扫描完毕, 就顺序的从数栈和符号栈中取出响应的数和符号, 进行运算, 并把最后的结果入数栈\n5. 最后的数栈只有一个数字 , 就是表达式的结果\n\n这里还需要仔细想想, 认真思考才能明白其中的意思\n\n代码如下, 需要配合上面的栈类来使用\n\n```js\n/**\n * 实现利用栈来解决算术表达式\n * @param str 表达式\n */\nfunction useStack(str){\n  let index = 0, num1, num2, oper, res, multNum = \'\'\n  let numStack = new Stack(10)\n  let charStack = new Stack(10)\n  while(true){\n    let ch = str.substr(index,1)\n    if(isOper(ch)){\n      if(charStack.isEmpty()){\n        charStack.push(ch)\n      }else{\n        if(level(ch) <= level(charStack.peek())){\n          num1 = numStack.pop()\n          num2 = numStack.pop()\n          oper = charStack.pop()\n          res = cal(num1,num2,oper)\n          numStack.push(res)\n          charStack.push(ch)\n        }else{\n          charStack.push(ch)\n        }\n      }\n    }else{\n      multNum += ch\n\n      if(index === str.length - 1){// 防止索引越界\n        numStack.push(parseInt(multNum))\n        multNum = \'\'\n      }else{ // 判断下一位是否为操作符\n        if(isOper(str.substr(index+1,1))){\n          numStack.push(parseInt(multNum))\n          multNum = \'\'\n        }\n      }\n    }\n    index++\n    if(index >= str.length) break\n  }\n  while(true){\n    if(charStack.isEmpty()) break\n    num1 = numStack.pop()\n    num2 = numStack.pop()\n    oper = charStack.pop()\n    res = cal(num1,num2,oper)\n    numStack.push(res)\n  }\n  console.log(numStack.pop())\n}\n\n/**\n * 实现计算\n * @param num1 数1\n * @param num2 数2\n * @param ch 操作符\n * @returns {number}\n */\nfunction cal(num1,num2,ch){\n  let res = 0\n  switch(ch){\n    case \'*\':\n      res = num1 * num2\n      break;\n    case \'+\':\n      res = num1 + num2\n      break;\n    case \'-\':\n      res = num2 - num1\n      break;\n    case \'/\':\n      res = num2 / num1\n      break;\n    default:\n      break;\n  }\n  return res\n}\n\n/**\n * 判断操作符的级别\n * @param ch 操作符\n * @returns {number}\n */\nfunction level(ch){\n  if(ch === \'*\' || ch === \'/\') return 1\n  else if(ch === \'+\' || ch === \'-\') return 0\n  else return -1\n}\n\n/**\n * 判断是否为操作符\n * @param ch 操作符\n * @returns {boolean}\n */\nfunction isOper(ch){\n  return ch === \'+\' || ch === \'-\' || ch === \'*\' || ch === \'/\'\n}\n```\n\n代码中的方法解释都写上了, 剩下就是自己理解的时候, 如果你理解了这个算数表达式的算法, 那么对栈的应用和理解也是相对熟练的了\n\n## 利用栈实现逆波兰表达式\n\n维基百科解释: \n\n>逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。\n\n他是一种表示表达式的操作, 我们可以用栈来实现逆波兰表达式\n\n具体思路如下: \n\n1. 输入一个逆波兰表达式(后缀表达式)\n2. 例如 (3+4)*5-6\n3. 从左至右扫描, 将 3 和 4 压入栈\n4. 遇到 + 运算符, 弹出 4 和 3, 计算 3 + 4 的值, 将 7 再次入栈\n5. 将 5 入栈\n6. 遇到 * 运算符, 弹出 5 和 7 , 计算 5 * 7, 将 35 在压入栈\n7. 将 6 入栈\n8. 遇到 - 运算符, 弹出 35 和 6, 计算 35 - 6 = 29 入栈\n9. 最后把 29 入栈, 就为最后的答案\n\n代码如下: \n\n```js\nfunction inversePolish(str){\n  let arr = str.split(\' \')\n  let stack = []\n  let num1,num2,char,res\n  for (let i=0;i<arr.length;i++){\n    if(/\\d+/.test(arr[i])){\n      stack.push(parseInt(arr[i]))\n    }else{\n      num1 = stack.pop()\n      num2 = stack.pop()\n      char = arr[i]\n      switch (char) {\n        case \'-\':\n          res = num2 - num1\n          break;\n        case \'+\':\n          res = num2 + num1\n          break;\n        case \'*\':\n          res = num2 * num1\n          break;\n        case \'/\':\n          res = num2 / num1\n          break;\n        default: break;\n      }\n      stack.push(res)\n    }\n  }\n  console.log(stack.pop())\n}\ninversePolish(\'3 4 + 5 * 6 -\')\n```\n','栈是一种最基础且常用的表达式',1595606400,1069),(0,49,1,'递归解决迷宫算法','## 递归\n\n递归简单来说就是函数的嵌套调用， 最常见的递归就是阶乘\n\n```js\nfunction sub(num){\n  if(num === 1){\n    return 1\n  }else{\n    return num * sub(num - 1)\n  }\n}\nconsole.log(sub(5)) // 120\n```\n如果 num 的值不等于 1， 那就一直递归 sub 函数，这个函数相当于 5 * 4 * 3 * 2 * 1 = 120\n\n## 递归解决迷宫\n\n迷宫问题和我们平常玩的迷宫是一样的， 从规定的起点开始， 通过不断的尝试， 然后找到终点\n\n![迷宫](http://121.199.1.64:7001/public/blog1595826575756.png)\n\n具体思路如下:\n\n1. map 表示地图\n2. i, j 表示从地图的哪个位置出发 (map\\[1]\\[1])\n3. 如蓝色能到红色位置, (map\\[6]\\[5]), 则说明迷宫通路找到\n4. 1 表示墙, 2 表示走过, 3 表示死路\n5. 走迷宫时要定一个策略, 比如 下 => 右 => 上 => 左, 如果该点走不通, 再回溯递归\n\n代码如下:\n\n```js\nconst recursion = () => {\n  // 创建二维数组\n  let map = []\n  for(let i=0;i<8;i++){\n    map[i] = []\n    for(let j=0;j<7;j++){\n      map[i][j] = 0\n    }\n  }\n  // 创建迷宫\n  for(let i=0;i<7;i++){\n    map[0][i] = 1\n    map[7][i] = 1\n  }\n  for(let i=0;i<8;i++){\n    map[i][0] = 1\n    map[i][6] = 1\n  }\n  map[3][1] = 1\n  map[3][2] = 1\n  // 开始迷宫游戏\n  dealMap(map,1,1)\n  console.log(map)\n}\nconst dealMap = (map,i,j) => {\n  if(map[6][5] === 2) return true\n  if(map[i][j] === 0){// 还没走过\n    map[i][j] = 2 // 已经在这个点上了表示已经走过\n    if(dealMap(map,i,j+1)) return true //左\n    else if(dealMap(map,i+1,j)) return true // 上\n    else if(dealMap(map,i,j-1)) return true //右\n    else if(dealMap(map,i-1,j)) return true //下\n    else { map[i][j] = 3; return false } // 上下左右走不通, 那就为死路, 返回 false\n  }else{\n    // 如果为 墙 或者死路 那就返回 false\n    return false\n  }\n}\n\nrecursion()\n```\n\n结果打印如下: \n\n```js\n[ [ 1, 1, 1, 1, 1, 1, 1 ],\n  [ 1, 2, 2, 2, 2, 2, 1 ],\n  [ 1, 0, 0, 0, 0, 2, 1 ],\n  [ 1, 1, 1, 0, 0, 2, 1 ],\n  [ 1, 0, 0, 0, 0, 2, 1 ],\n  [ 1, 0, 0, 0, 0, 2, 1 ],\n  [ 1, 0, 0, 0, 0, 2, 1 ],\n  [ 1, 1, 1, 1, 1, 1, 1 ] ]\n```\n\n2 走过的路就是迷宫的一种走法, 当改变策略的时候, 迷宫走法就会改变, 这个就作为扩展题, 有兴趣的小伙伴去试一试','递归是一种很有效的算法',1595779200,1090),(0,51,1,'递归回溯解决八皇后问题','## 八皇后问题\n\n维基百科解释: \n\n>八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解[1]。\n\n\n\n如何实现一个八皇后问题, 那当然先得读懂题目, 我们来分析一下\n\n1. 棋盘为 8 * 8 的上面分别摆放八个皇后\n2. 皇后之间不能在同一行, 同一列, 和同一斜线上\n3. 然后看看有几种解法\n\n下面我推荐你去玩一下关于[八皇后的小游戏](http://www.4399.com/flash/42643_1.htm), 这样更容易理解\n\n## 解题思路\n\n![八皇后](http://121.199.1.64:7001/public/blog1595840197311.png)\n\n\n1. 第一个皇后先放在第一行第一列\n2. 第二个皇后放在第二行第一列, 判断是否符合条件, 如果不符合继续放在第二列, 第三列, 直到所有列放完\n3. 继续放第三个皇后, 还是第一列, 第二列, 如此循环知道第 8 个皇后放在最后一列相互不冲突\n4. 当得到一个正解, 在栈回退到上一个栈, 就会开始回溯, 即将第一个皇后放到第一列的所有正解全部得到\n5. 然后回头继续放第一个皇后在第二列, 后面循环第 1 ~ 4 部\n\n## 代码实现\n\n代码不难, 但是其思路不容易搞懂, 我基本上把每一行的代码都有相应的注释, 如果不懂可以通过邮箱 18322276773@163.com 求助我, 或者找你身边的大神问问, 或者你自己思考思考, 根据代码也一步一步回溯一下来助于理解\n\n```js\nconst resolveQueen = (th) => {\n  // 设置八皇后\n  let maxSize = 8\n  // 设置皇后的位置数组, 一维数组就可以显示, arr[i] = val, 表示 val + 1 列, 第 i + 1 个皇后, 第 i + 1 个行\n  let arr = new Array(maxSize)\n\n  check(th)\n\n  /**\n   * 递归方法\n   * @param th 第几个皇后\n   */\n  const check = (th) => {\n    // 如果第 th 个皇后等于 8, 那么说明 8 个皇后已经递归完, 输出递归方法\n    if(th === maxSize) return console.log(arr)\n    // 循环递归皇后\n    for(let i=0;i<maxSize;i++){\n      // 先把第 th 个皇后放在第一列, 如果不行的话, 继续循环\n      arr[th] = i\n      // 判断是否在同一行 斜线 列, 如果不在, 则继续摆下一个皇后\n      if(judge(th)) check(th + 1)\n    }\n\n  }\n\n  /**\n   * 判断位置是否正确\n   * @param th 第几个皇后\n   */\n  const judge = (th) => {\n    for(let i=0;i<th;i++){\n      // 1. [i] === arr[th] 表示如果在同一列\n      // 2. Math.abs(th - i) === Math.abs(arr[th] - arr[i]) 表示如果为斜线\n      if(arr[i] === arr[th] || Math.abs(th - i) === Math.abs(arr[th] - arr[i])){\n        return false\n      }\n    }\n    return true\n  }\n}\nresolveQueen(0)\n```\n','来让八个皇后互相伤害',1595779200,1049),(0,52,1,'二叉树前中后序遍历和查找元素','## 构建节点类\n\n### 基本结构\n\n1. 节点的值\n2. 节点的左孩子\n3, 节点的右孩子\n\n```js\nclass Node {\n  constructor(val) {\n    this.val = val\n    this.left = null\n    this.right = null\n  }\n}\n```\n\n### 遍历方法\n\n- 前序遍历: 先输出父节点, 在遍历左子树和右子树\n- 中序遍历: 先遍历左子树, 再输出父节点, 在遍历右子树\n- 后序遍历: 先遍历左子树, 在遍历右子树, 最后输出父节点\n\n总结: 前中后判断依据是父节点的输出顺序\n\n代码实现: \n\n```js\n// 前序\npreOrder() {\n    console.log(this.val)\n    if (this.left !== null) {\n      this.left.preOrder()\n    }\n    if (this.right !== null) {\n      this.right.preOrder()\n    }\n  }\n// 中序\n  midOrder() {\n    if (this.left !== null) {\n      this.left.midOrder()\n    }\n    console.log(this.val)\n    if (this.right !== null) {\n      this.right.midOrder()\n    }\n  }\n// 后序\n  backOrder() {\n    if (this.left !== null) {\n      this.left.backOrder()\n    }\n    if (this.right !== null) {\n      this.right.backOrder()\n    }\n    console.log(this.val)\n  }\n```\n\n### 查找方法\n\n和遍历方法是一样的\n\n- 前序: 父节点先与要查找的节点比较, 如果相同就返回, 否则在遍历当前节点的左子树, 如果没有找到就遍历当前节点的右子树, 如果遍历完还是没有就直接返回 null\n- 中序: 先遍历当前节点的左子树, 如果找到返回, 如果没找到就看当前节点的值是否与要寻找的值相同, 不同在遍历右子树, 如果还找不到返回 null\n- 后序: 先遍历左子树, 找到返回, 然后在遍历右子树, 找到返回, 最后在对比当前节点和要查找到值是否相同, 不相同那说明没有找到, 返回 null\n\n```js\npreOrderSearch(val) {\n    console.log(\'pre\')\n    let temp = null\n    if (this.val === val) return this\n    if (this.left !== null) temp = this.left.preOrderSearch(val)\n    if (temp !== null) return temp\n    if (this.right !== null) temp = this.right.preOrderSearch(val)\n    return temp\n  }\n\n  midOrderSearch(val) {\n    let temp = null\n    if (this.left !== null) temp = this.left.midOrderSearch(val)\n    if (temp !== null) return temp\n    console.log(\'mid\') // 位置要在真正比较前面, 否则就包括判空的步骤\n    if (this.val === val) return this\n    if (this.right !== null) temp = this.right.midOrderSearch(val)\n    return temp\n  }\n\n  backOrderSearch(val) {\n    let temp = null\n    if (this.left !== null) temp = this.left.backOrderSearch(val)\n    if (temp !== null) return temp\n    if (this.right !== null) temp = this.right.backOrderSearch(val)\n    if (temp !== null) return temp\n    console.log(\'back\')  // 位置要在真正比较前面, 否则就包括判空的步骤\n    if (this.val === val) return this\n    return temp\n  }\n```\n\n## 树类\n\n### 创建树类\n\n树是多个节点组成的, 所以它有一个根节点和多个子节点\n\n每个节点之间是引用连接的, 所以只给树一个根节点就好\n\n```js\nclass Tree {\n  constructor(root) {\n    this.root = root\n  }\n}\n```\n\n### 创建树的遍历和查找方法\n\n真正的方法都在节点类上, 所以树中的方法只是包裹了一下\n\n这里遍历和查找方法就一起写了, 只是一遍封装, 没什么技术含量\n\n```js\n // 前序遍历\n  fpreOrder() {\n    if (this.root !== null) {\n      this.root.preOrder()\n    }\n  }\n // 中序遍历\n  fmidOrder() {\n    if (this.root !== null) {\n      this.root.midOrder()\n    }\n  }\n  // 后序遍历\n  fbackOrder() {\n    if (this.root !== null) {\n      this.root.backOrder()\n    }\n  }\n  // 前序查找\n  fpreOrderSearch(val){\n    if(this.root !== null){\n      return this.root.preOrderSearch(val)\n    }else {\n      return null\n    }\n  }\n  // 中序查找\n  fmidOrderSearch(val){\n    if(this.root !== null){\n      return this.root.midOrderSearch(val)\n    }else {\n      return null\n    }\n  }\n  // 后序查找\n  fbackOrderSearch(val){\n    if(this.root !== null){\n      return this.root.backOrderSearch(val)\n    }else {\n      return null\n    }\n  }\n```\n\n遍历和查找方法写完了, 就可以测试一下了, 这里没有写自动添加子节点的方法, 必须自己手动添加子节点构成树, 当然这样更容易理解树是怎么形成的\n\n```js\nconst root = new Node(1)\nconst n1 = new Node(2)\nconst n2 = new Node(3)\nconst n3 = new Node(4)\nroot.left = n1\nroot.right = n2\nn2.right = n3\nconst tree = new Tree(root)\n\nconsole.log(tree.fpreOrderSearch(4))\nconsole.log(tree.fmidOrderSearch(4))\nconsole.log(tree.fbackOrderSearch(4))\n```\n\n这里我只测试了二叉树查找元素, 遍历元素也是同理, 有兴趣的可以试一下','简单介绍二叉树的基本用法',1596211200,1064),(0,54,1,'堆排序','## 堆\n\n堆是具有以下性质的完全二叉树: \n\n1. 每个节点的值都**大于或等于其左右孩子节点的值, 称为大顶堆**\n2. 每个节点的值都**小于或等于其左右孩子节点的值, 称为小顶堆**\n\n## 堆排序\n\n基本思路: \n\n1. 将待排序的序列构成一个大顶堆\n2. 此时这个序列的最大值就是堆顶的根节点\n3. 就其与末尾元素进行交换, 此时末尾就是最大值\n4. 然后将剩余的 n-1 个元素重新建成一个大顶堆, 然后重复 2~3 步知道排序完成\n\n代码如下; \n\n```js\nconst buildHeap = (arr, i, length) => {\n  // 先父节点\n  let temp = arr[i]\n  // 开始调整\n  for(let k = i*2+1;k<length;k=k*2+1){\n    // 如果左孩子比右孩子大, 那么索引就换到右孩子\n    if(k+1 < length && arr[k] < arr[k+1]){\n      k++\n    }\n    // 父节点比孩子节点小, 那么就把孩子节点的值给父节点\n    if(temp < arr[k]){\n      arr[i] = arr[k]\n      // 然后把索引给了右孩子在比较孩子的孩子节点是否大小\n      i = k\n    }\n  }\n  // 把所有的节点都比较完后, 再把最初的父节点赋给现在的 i 索引, 完成建堆\n  arr[i] = temp\n}\nconst heapSort = arr => {\n  // 建堆\n  for(let j=Math.floor(arr.length/2-1);j>=0;j--){\n    buildHeap(arr,j,arr.length)\n  }\n  // 排序\n  for(let j=arr.length-1;j>=0;j--){\n    let temp = arr[j]\n    arr[j] = arr[0]\n    arr[0] = temp\n    buildHeap(arr,0,j)\n  }\n  return arr\n}\n```\n\n','建堆以及堆排序实现',1596297600,1039),(0,55,1,'leetcode 104.二叉树的最大深度','## 题解\n\n[传送门](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\n\n利用递归\n\n如果有子节点, 那么就继续递归, 如果没有那就结束递归\n\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0\n    return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1\n};\n```\n\n利用广度优先搜索\n\n```js\nvar maxDepth = function(root) {\n    if(!root) return 0\n    let queue = []\n    queue.push(root)\n    let max = 0\n    while(queue.length){\n        const size = queue.length\n        for(let i=size;i>0;i--){\n           const node = queue.shift()\n           if(node.left) queue.push(node.left)\n           if(node.right) queue.push(node.right)\n        }\n        max++\n    }\n    return max\n};\n```','leetcode 刷题',1598198400,1020),(0,56,1,'leetcode 680. 验证回文字符串 Ⅱ','## 题解\n\n[传送门](https://leetcode-cn.com/problems/valid-palindrome-ii/)\n\n刚开始做这道题的思路就是先判断不删除字符是否回文, 很简单\n\n1. 把字符串转成数组然后反转一下, 再转为字符串, 判断是否相等\n\n删除字符可以和字符反转结合, 依次删除字符串的字符, 然后在进行反转对比, 但是这样的时间复杂度为 O(n^2), 所以会出现超时通不过\n\n**看了题解后可以用贪心算法去解决问题**\n\n1. 使用两个指针 low high 分别指向字符串的第一个和最后一个, 依次让他们所在的字符对比, 如果相同那么 low++. high--, 当 low 和 high 位置重合之后, 就结束循环\n2. 如果其中有元素不同, 那么有两种情况\n    - low 位删除字符, 那么对比 low+1 和 high 是否相同, 如果相同, 那么说明删除一个字符实现了回文\n    - high 删除字符,对比 low 和 high - 1 是否相同, 如果相同, 那么说明删除一个字符实现回文\n3. 如果循环完成, 那么说明会问完成, 返回 true\n\n具体代码如下: \n\n```js\nvar validPalindrome = function(s) { // 贪心算法`\n    let low = 0\n    let high = s.length - 1\n    while(low < high){\n        if(s.charAt(low) === s.charAt(high)){\n            low++\n            high--\n        }else{\n            let flag1 = flag2 = true\n            for(let i=low,j=high-1;i<j;i++,j--){\n                if(s.charAt(i) !== s.charAt(j)){\n                    flag1 = false\n                    break\n                }\n            }\n            for(let i=low + 1, j = high;i<j;i++,j--){\n                if(s.charAt(i) !== s.charAt(j)){\n                    flag2 = false\n                    break\n                }\n            }\n            return flag1 || flag2\n        }\n    }\n    return true\n};\n```','leetcode 刷题',1598889600,1041),(0,57,1,'leetcode 19. 删除链表的倒数第N个节点','## 题解\n\n[传送门](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n方法一: 双循环解决\n\n1. 倒数第 n 个实际就是 **链表的长 - n + 1** 个节点, 要删除一个节点, 那么就让前一节点的 next 指向删除节点的 .next \n2. 首先求出链表的长度, 利用 while 循环\n3. 然后在遍历到删除节点的前一节点\n4. 执行 temp.next = temp.next.next\n\n```js\nconst removeNthFromEnd = function(head, n) {  \n    //两次遍历算法\n    const preHead = new ListNode(0)\n    preHead.next = head\n    let first = head\n    let len = 0\n    while(first !== null){\n        len++\n        first = first.next\n    }\n    len -= n\n    first = preHead\n    while(len > 0){\n        first = first.next\n        len--\n    }\n    first.next = first.next.next\n    return preHead.next\n}\n```\n\n方法二: 双指针一次遍历\n\n1. 设置两个指针, 第一个指针循环到 n + 1 的位置\n2. 然后第二个指针还在头结点处\n3. 当第一个指针到了 n + 1 的位置, 两个指针同时遍历, 知道第一个指针为 null\n\n```js\nconst removeNthFromEnd = function(head, n) {  \n    // 一次遍历算法, 双指针\n    let preHead = new ListNode(0)\n    preHead.next = head\n    let first = preHead\n    let second = preHead\n    for(let i = 0;i < n + 1;i++){\n        first = first.next\n    }\n    while(first !== null){\n        first = first.next\n        second = second.next\n    }\n    second.next = second.next.next\n    return preHead.next\n}\n```','leetcode 刷题',1598889600,1007),(0,58,1,'leetcode 70. 爬楼梯/98. 验证二叉搜索树','## 70.爬楼梯\n\n[传送门](https://leetcode-cn.com/problems/climbing-stairs/submissions/)\n\n>法一: 动态规划解法\n\n这是一道经典的动态规划题, 根据题目描述, 可推出公式 \n\n**f(n) = f(n-1) + f(n-2)**\n\n也就是说第 n 级楼梯的方法数是前一级楼梯和前两级楼梯方法数的结合\n\n所以根据公式我们可以依据一个循环来实现方法数量的叠加\n\n```js\nvar climbStairs = function(n) {\n    //动态规划\n    let p = q = 0, r = 1\n    for(let i=0;i<n;i++){\n        p = q\n        q = r\n        r = p + q\n    }\n    return r\n};\n```\n\n>法二: 递归解法\n\n因为有了公式, 那么就可以抽取出规律来实现, 而简单的递归会超出时长, 因为其中递归遍历会重复计算, 所以用一个数组来实现数据持久化, 当访问到已计算过的值, 就返回第一次访问时存在数组里的值\n\n```js\nvar climbStairs = function(n) {\n    // 优化递归方法\n    const helper = (n,memo) => {\n        // 利用一个数组去存储递归过得值\n        if(memo[n] > 0) return memo[n]\n        if(n === 1) {\n            memo[n] = 1\n        }else if(n === 2){\n            memo[n] = 2\n        }else{\n            memo[n] = helper(n-1,memo) + helper(n-2,memo)\n        }\n        return memo[n]\n    }\n    return helper(n,[])\n};\n```\n\n\n## 98.验证二叉搜索树\n\n[传送门](https://leetcode-cn.com/problems/validate-binary-search-tree/)\n\n> 法一: 递归实现\n\n遍历二叉树去判断是否为二叉搜索树, 当然第一想到的就是递归实现\n\n当左子树有节点, 那么左子树就小于 root.val, 当右子树有节点, 那么右子树就大于 root.val, 那么子树也为一个二叉搜索树\n\n所以需要一个区间来判断是否条件成立, 也就是说左子树或右子树有节点跳出区间, 那么就不是二叉搜索树\n\n```js\nvar isValidBST = function(root) {\n    //递归方法\n    const helper = (root,lower,upper) => {\n        if(!root) return true\n        if(root.val <= lower || root.val >= upper) return false\n        return helper(root.left,lower,root.val) && helper(root.right,root.val,upper)\n    }\n    return helper(root,-Infinity,Infinity)   \n};\n```\n\n> 法二: 利用中序遍历实现\n\n中序遍历有一个特点, 那就是对于二叉搜索树遍历完后他的结果是升序的, 所以可以借助中序遍历实现本题\n\n利用栈来存储遍历过得值, 然后依次出栈, 判断出栈节点的值是否大于前一节点的值, 如果不大于那么就说明不是二叉搜索树\n\n```js\nvar isValidBST = function(root) {\n     // 利用中序遍历\n    const stack = []\n    let order = -Infinity\n    while(stack.length || root !== null){\n        while(root){\n            stack.push(root)\n            root = root.left\n        }\n        root = stack.pop()\n        // 如果中序遍历节点的值小于等于前一个节点的值, 那么就说明不是升序\n        if(root.val <= order) return false\n        order = root.val\n        root = root.right\n    }\n    return true\n};\n```\n\n','leetcode 刷题',1599148800,1068),(0,59,1,'leetcode 437. 路径总和 III','## 题解\n[传送门](https://leetcode-cn.com/problems/path-sum-iii/)\n\n利用双递归的思想, 这道题以为两个递归回溯比较绕, 我的大体思路是这样\n\n1. 从根节点开始找符合路径, 依次递归遍历完所有节点, 得出路径之和\n2. 然后再从根节点左子节点找符合路径, 依次遍历, 得出路径之和\n3. 从根节点的右子节点找符合路径, 得出路径之和\n4. 重复 1~3 步直到遍历完所有节点\n\n```js\nvar pathSum = function (root, sum) {\n  if (!root) return 0 // 如果节点不存在, 返回 0\n  const page = findPath(root, sum) // 从根节点开始找符合路径\n  const sum1 = pathSum(root.left, sum) // 以左子节点为开端找\n  const sum2 = pathSum(root.right, sum) // 以右子节点为开端\n  return page + sum1 + sum2 // 返回所有节点共同找到的路径总和\n}\n\nfunction findPath(node, sum) {\n  if (!node) return 0 // 节点不存在返回 0\n  const flag = node.val === sum ? 1 : 0 // 如果当前节点的值等于 sum, 那么就找到一条路径\n  const path1 = findPath(node.left, sum - node.val) // 从左子节点找, 并让路径总和减去当前节点的值\n  const path2 = findPath(node.right, sum - node.val)\n  // 从右子节点找, 并让路径总和减去当前节点的值\n  return flag + path1 + path2 // 返回从当前节点找到的路径总和\n}\n```\n\n每一步我在代码里都加上了注释, 更易于理解, 它整体是一个自顶向下的过程, 记住这个你就会找到问题的核心点, 读懂代码就很容易了\n\n','leetcode 刷题',1599840000,1004),(0,60,3,'I can wait forever','[传送门](http://music.163.com/song?id=21609201&userid=312009869)\n\n此歌对于将要结婚的情侣很适合, 我不能等太久就想和你一起生活, 表白也很适合, 希望疫情快点过去, 也祝愿我们过得过来越好\n\n```css\nYou look so beautiful today\n今天，你真迷人\nIt\'s like every time I turn around, I see your face\n好像每次转身都能看到你的脸\nThe thing I miss the most is, waking up next to you\n我梦想着在你身边醒来\nWhen I look into your eyes, man I wish that I could stay\n当我凝视你的眸子，我多么期望能找到我自己\nAnd I can\'t lie, every time I leave my heart turns gray\n真的，每次离别总会伤感\nAnd I wanna come back home to see your face\n我想在家里看到你的脸\nAnd I.Cuz I just can\'t take it\n我无法承受思念\n```\n\n','Simple Plan 的抒情之歌 ',1599840000,1085),(0,61,1,'数组中出现次数最多的字符','## 题解\n\n在某公司笔试遇到这个题, 那会时间到了没有写完 (猛男哭泣>_<), 很巧的是今天又让我碰到了这个题, 真有缘, 那就让我来记录一下吧\n\n思路: \n\n1. 根据题意可知数组肯定是有重复元素的, 而且要记录出现的次数, 最后输出的是数组的元素\n2. 这就需要一个映射效果来记录元素出现次数, 可以使用 ES6 新出的 Map 结构, 以键值对的形式去存储\n3. 然后把 Map 转为数组 (注意 Map 结构转为数组为二维数组) 排序遍历找到出现次数最多的元素, 输出前三个元素就可以\n\n```js\nconst findArrMax = (arr) => {\n  const map = new Map()\n  arr.forEach((item) => {\n    if (map.has(item)) {\n      map.set(item, map.get(item) + 1)\n    } else {\n      map.set(item, 1)\n    }\n  })\n  const arr1 = Array.from(map).sort((a, b) => b[1] - a[1])\n  return [arr1[0][0], arr1[1][0], arr1[2][0]]\n}\n```\n一些解算法题的建议: \n\n解题前要思考, 不要上来看完题就开始解, 那样往往会拖慢你的解题思路, 想好了本题用的数据结构, 还有必要时用到算法, 都要考虑清楚, 最好在草稿上去画一下, 走一走流程, 在写代码的时候想着之前的思路, 代码自然就出来了, 每天都要看一看算法, 也不要只是为了应试而去刷算法, 这个需要养成一个良好的习惯, 就像学习一样, 短时间内看不到效果, 但是不积跬步无以至千里, 坚持下去, 在时机成熟那一天, 你付出的都会得到回报, 加油, 继续学习\n\n## 更新信息\n\n今天才发现这道题在 leetcode 上有原型, [传送门](https://leetcode-cn.com/problems/top-k-frequent-elements/)\n\nleetcode 是只是把显示前三个元素变为显示前 k 个元素, 有兴趣的可以去做一下, 只需要把上面代码改动一下就得出结果\n','笔试算法题',1601049600,1083),(0,63,1,'leetcode235. 二叉搜索树的最近公共祖先','## 题解\n\n[传送门](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n> 法一 :  两次循环分别找到 p, q 所在的路径\n\n- 写一个递归函数去遍历搜索树, 根据搜索树节点大小的特点判断如果 p 小于当前节点, 那么就往左子树找, 如果大于当前节点, 就往右子树找, q 节点同理\n- 然后把找到的路径节点依次存到数组里\n- p, q 的路径数组里最后一位相同的节点就是他们的公共祖先\n\n![节点图](http://121.199.1.64:7001/public/blog1601173971686.png)\n\n这里借助一下官方的图解释一下, 当 p 和 q 为 2 , 8 那么找出他们的路径 pPath[6,2] 和 qPath[6,8] 然后找出最后一个相同的节点就是 6, 所以结果为 6\n\n```js\nconst lowestCommonAncestor = (root, p, q) => {\n  if (!root) return\n  const helper = (node, value) => {\n    const path = []\n    while (node !== value) {\n      if (!node) break\n      path.push(node)\n      if (node.val < value.val) {\n        node = node.right\n      } else {\n        node = node.left\n      }\n    }\n    path.push(node)\n    return path\n  }\n  const qPath = helper(root, q)\n  const pPath = helper(root, p)\n  let result\n  for (let i = 0; i < qPath.length && i < pPath.length; i++) {\n    if (pPath[i] === qPath[i]) {\n      result = pPath[i]\n    } else {\n      break\n    }\n  }\n  return result\n}\n```\n\n> 法二: 一次循环, 同时遍历 p, q\n\n思路和法一基本相同, 在一次循环遍历节点, 如果 p 和 q 都小于当前节点, 那么就从当前节点的左子树找, 相反如果都大于当前节点, 那么从当前节点的右子树找, 如果等于当前节点的话就直接返回他们共同的节点\n\n```js\nconst lowestCommonAncestor = (root, p, q) => {\n  let result = root\n  while (true) {\n    if (result.val > p.val && result.val > q.val) {\n      result = result.left\n    } else if (result.val < p.val && result.val < q.val) {\n      result = result.right\n    } else {\n      break\n    }\n  }\n  return result\n}\n```','leetcode 每日刷题',1601136000,1077),(0,64,1,'leetcode5. 最长回文子串','## 题解\n\n[传送门](https://leetcode-cn.com/problems/longest-palindromic-substring/)\n\n### 暴力解法\n\n1. 设定最长回文长度为 maxLen = 1, 开始回文的索引 begin = 0\n2. 第一层循环从字符串 s 的第 i = 0 索引开始, 表示回文子串第一个元素, 所以 i 作为开始子串索引要小于 s.length - 1, 也就是说不能为最后一位\n3. 第二层循环从 j = i + 1 的索引开始, 表示回文子串的最后一个索引元素\n4. 当最大的回文长度 j - i + 1 (这里因为 i, j 为索引值, 所以要取长度要 +1) 大于 maxLen 并且判断本字符串是否回文(这里用一个单独的函数提取回文方法)\n5. 如果回文, 那么就把这个子串长度给 maxLen, 而且 begin 索引为 i\n6. 如果不回文, 那么就继续循环, 直到循环结束\n7. 循环结束后的 begin 和 maxLen 就是最长回文子串的开始索引和长度, 利用 substring 方法截取子串, 得出结果\n\n```js\nconst longestPalindrome = function(s) {\n    // 暴力解法\n    if(s.length < 2) return s\n    const len = s.length\n    let maxLen = 1\n    let begin = 0\n    for(let i=0;i<len-1;i++){\n        for(let j=i+1;j<len;j++){\n            if(j - i + 1 > maxLen && huiWen(s,i,j)){\n                maxLen = j - i + 1\n                begin = i\n            }\n        }\n    }\n    return s.substring(begin,begin + maxLen)\n};\nconst huiWen = (s,left,right)=>{\n    while(left<right){\n        if(s[left] !== s[right]){\n            return false\n        }\n        left++\n        right--\n    }\n    return true\n}\n```\n','leetcode刷题',1602172800,1018),(0,65,1,'leetcode121. 买卖股票的最佳时机','## 题解\n[传送门](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)\n\n### 解法一: 暴力法\n\n1. 买卖股票, 也就是前几天买, 后几天卖, 顺序可不能弄错\n2. 所以可以用两次遍历方法, 利用后一个减去前一个得出差值\n3. 然后依次重复 2 步骤找到差值最大的就搞定\n\n```js\nconst maxProfit = function(prices) {\n   let max = 0\n   for(let i=0;i<prices.length-1;i++){\n       for(let j=i+1;j<prices.length;j++){\n           const c = prices[j] - prices[i]\n           if(c > max){\n               max = c\n           }\n       }\n   }\n   return max\n};\n```\n\n- 时间复杂度: O(n^2)\n- 空间复杂度: O(1)\n\n### 解法二: 一次循环\n\n1. 找出出售股票的最低点\n2. 然后在让最低点的后面几天去减去最低点的值\n3. 重复步骤 2 找出最大插值\n\n```js\nconst maxProfit = function(prices) {\n  let min = Infinity\n  let result = 0\n  for(let i=0;i<prices.length;i++){\n      if(prices[i] < min){\n          min = prices[i]\n      }else{\n          if(prices[i] - min > result){\n              result = prices[i] - min\n          }\n      }\n  }\n  return result\n};\n```\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(1)','leetcode刷题',1602777600,1093),(0,66,2,'装台: 装的是中国普通人的生活百态','## 装台\n\n![装台海报](http://121.199.1.64:7001/public/blog1609058955285.jpeg)\n\n装台是由获得第十届茅盾文学奖的 [陈彦](https://zh.wikipedia.org/wiki/%E9%99%88%E5%BD%A6_(%E7%BC%96%E5%89%A7)) 的原作改编, 由李少飞指导的一部电视剧\n\n这部剧给我的一个感受就是真实, 像极了我们中国大部分老百姓的生活, 电视剧中没有大风大浪, 多的知识家长里短, 生活琐碎, 但叫人十分爱看, 剧中主人公刁大顺(张嘉译)是一个靠装台为生的西安人, 他带领这一伙农名工主要给秦腔团装台, 同时也接一些其他的装台杂活, 要说这装台和搭台不一样, 装台是带有艺术气息的, 不是普通的搭台工作, 就这样围绕一伙人展开的 幽默诙谐的生活故事\n\n## 装的是台, 活的是人生\n\n因为我本身是做互联网的, 所以对其中的人物刁大雀儿深有同情, 他为了给孩子治病, 白天黑夜的挣钱, 不要命的挣钱, 最后因为心脏病猝死在北京, 觉得他这样年纪轻轻的孩子刚七八岁, 因为过劳死不值, 相对比我们互联网行业来说, 猝死在工作场所已经见怪不怪, 现在加班加点的工作已经是常态, 不管大公司小公司都学习这样的风气, 这样靠堆时间来完成的工作效率不高而且对身体也有极大的伤害\n\n有没有不用加班提高效率的办法呢, 也有, 就是工作时间努力工作, 多组之间联调提测的时候要协同, 不能偷懒, 尽快吧接口调好  , 这样让产品如期上线, 这样不是更好, 但往往不如人意的就是调试的问题, 写代码只是一两天就可以完成, 但是多人协作调试的时候就会出很多问题, 这就得提升一个团队的凝聚力和团结力, 这样会考虑到很多的问题和冲突, 解决不了就加班解决, 然后一直恶性循环下去\n\n所以治本对我们来说很重要\n\n## 刁大顺, 心态好就很顺\n\n我很看好主人公刁大顺的心态, 他一生没有什么本事, 靠装台把两个女儿养活成人, 一辈子劳碌命, 不干活就没钱吃饭, 但是他有一个很好的优点, 就是踏实, 对谁都是坦诚相待, 绝没有害人的想法, 而且心善, 走到哪都留下好名声, 最后钓的金龟婿, 收获美人归, 都是他对自己的手下好, 也对自己的情敌三皮好才有这样的结果, 反观他的大哥, 打肿脸充大款, 每次回来豪气得很, 谁知道他在外边是拆了东墙补西墙, 自己受苦回乡装着富贵赚了大钱, 最后把身体也累垮了, 这样好面子的人苦了自己, 只为他人口中的那点好, 我实在感觉不值, 还是踏踏实实, 一步一个脚印来的好\n\n当然剧中不只这么多内容, 我只是把我印象中最深的两个人物说了一下, 其实剧中还有很多值得剖析的人物, 比如说刁菊花, 蔡老师, 三皮等等, 这部剧真的我特别推荐, 如果你喜欢陕西文学, 又正好有时间, 那么我强烈建议你去看一下这部剧\n\n\n\n\n\n\n\n\n\n','装台是最近非常火的一部带有地方特色的电视剧',1608998400,1032),(0,67,4,'牛年大吉','## 新的轮回\n\n不知不觉已经到了自己第二个本命年了, 时间过得真快啊, 转眼就成为了大人, 可是小时候的事情还是历历在目, 也是感叹人生无常, 白驹过隙, 我将在2021完成自己的学生生涯, 开始了工作的生活, 是一种机遇更是一种挑战, 很庆幸的是可以去一个很好的公司, 也是我期待的公司, 我现在也提前来实习了两个月了, 公司氛围很不错, 自己对工作上的内容也可以胜任, 接触到了很多学校不会教授的东西, 整个项目开发流程很长, 需要很多环节, 任何一个环节的错误都会导致最终效果的不如人意\n\n我在项目业务方面也还是有很多没有学到的地方, 希望自己在新的一年里顺利毕业, 入职实习的公司, 增强自己的专业技术和能力, 也为整个项目贡献自己的一份力量, 我现在越来越觉得只有自己足够优秀, 才能获得自己想要的一切, 所以还是要继续努力, 人生只一次, 也好好为自己去拼搏一次\n\n在前端方面自己也从一个小白阶段到了中级阶段, 可以驾驭一些框架, 知晓一些设计模式, 也可以独立完成团队分配的任务, 在这里特别感谢我的导师两个月里对我的教导, 让我更快的融入团队, 也更快的自我学习\n\n2020 是不平凡的一年, 中国甚至全世界都在新冠的笼罩之下努力的抗击着, 现在全球感染新冠人数已经超过1亿人, 但对于我们中国14亿人口来说只感染了9万人, 说起这个我顿时为自己是中国人而感到骄傲, 2021中国疫苗将普及, 而且完全免费接种, 这对于我们打击新冠肺炎是一个强有力的措施, 当我们实现了全民疫苗的时候, 也是我们真正战胜新冠的时候, 我相信在2021年就可以完成这个目标\n\n最后祝大家牛年大吉, 工作顺利, 身体健康, 完事如意','2021 也是自己的本命年',1613145600,1006);
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `blog_content`
--

DROP TABLE IF EXISTS `blog_content`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `blog_content` (
  `title` varchar(100) DEFAULT NULL,
  `type` varchar(10) DEFAULT NULL,
  `content` varchar(100) DEFAULT NULL,
  `introduce` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_content`
--

LOCK TABLES `blog_content` WRITE;
/*!40000 ALTER TABLE `blog_content` DISABLE KEYS */;
INSERT INTO `blog_content` VALUES ('meng','生活','我是一个猪',NULL);
/*!40000 ALTER TABLE `blog_content` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `comment_content` longtext,
  `datetime` longtext,
  `article_id` int(11) DEFAULT NULL,
  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
INSERT INTO `comments` VALUES ('辛苦了','2020年11月11日',65,12);
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `image`
--

DROP TABLE IF EXISTS `image`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `image` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `path` varchar(300) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=69 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `image`
--

LOCK TABLES `image` WRITE;
/*!40000 ALTER TABLE `image` DISABLE KEYS */;
INSERT INTO `image` VALUES (5,'http://121.199.1.64:7001/public/blog1593591939176.png'),(6,'http://121.199.1.64:7001/public/blog1593593017917.jpeg'),(7,'http://121.199.1.64:7001/public/blog1593599091557.jpeg'),(10,'http://121.199.1.64:7001/public/blog1593918355018.png'),(12,'http://121.199.1.64:7001/public/blog1594721125515.jpeg'),(13,'http://121.199.1.64:7001/public/blog1595325129312.jpeg'),(14,'http://121.199.1.64:7001/public/blog1595393836272.png'),(15,'http://121.199.1.64:7001/public/blog1595476748460.png'),(16,'http://121.199.1.64:7001/public/blog1595485965778.png'),(17,'http://121.199.1.64:7001/public/blog1595556395164.png'),(18,'http://121.199.1.64:7001/public/blog1595826575756.png'),(19,'http://121.199.1.64:7001/public/blog1595839568570.png'),(20,'http://121.199.1.64:7001/public/blog1595840197311.png'),(21,'http://121.199.1.64:7001/public/blog1601173971686.png'),(22,'http://121.199.1.64:7001/public/blog1601867592731.jpeg'),(23,'http://121.199.1.64:7001/public/blog1601868078140.jpeg'),(24,'http://121.199.1.64:7001/public/blog1601868269566.jpeg'),(25,'http://121.199.1.64:7001/public/blog1601868440493.jpeg'),(26,'http://121.199.1.64:7001/public/blog1601868589484.jpeg'),(27,'http://121.199.1.64:7001/public/blog1601868735823.jpeg'),(28,'http://121.199.1.64:7001/public/blog1601868866387.jpeg'),(29,'http://121.199.1.64:7001/public/blog1601868910022.jpeg'),(30,'http://121.199.1.64:7001/public/blog1601869060551.jpeg'),(31,'http://121.199.1.64:7001/public/blog1601869306012.jpeg'),(32,'http://121.199.1.64:7001/public/blog1601869386831.jpeg'),(33,'http://121.199.1.64:7001/public/blog1601869444442.jpeg'),(34,'http://121.199.1.64:7001/public/blog1601869584028.jpeg'),(35,'http://121.199.1.64:7001/public/blog1601869779953.png'),(36,'http://121.199.1.64:7001/public/blog1601869940852.jpeg'),(37,'http://121.199.1.64:7001/public/blog1601870022060.jpeg'),(38,'http://121.199.1.64:7001/public/blog1601870125257.jpeg'),(39,'http://121.199.1.64:7001/public/blog1601870195616.jpeg'),(41,'http://121.199.1.64:7001/public/blog1601870267023.jpeg'),(42,'http://121.199.1.64:7001/public/blog1601870330544.jpeg'),(43,'http://121.199.1.64:7001/public/blog1601870469977.jpeg'),(44,'http://121.199.1.64:7001/public/blog1601870533296.jpeg'),(45,'http://121.199.1.64:7001/public/blog1601870607788.jpeg'),(46,'http://121.199.1.64:7001/public/blog1601870674396.jpeg'),(47,'http://121.199.1.64:7001/public/blog1601870731802.jpeg'),(48,'http://121.199.1.64:7001/public/blog1601870811084.jpeg'),(49,'http://121.199.1.64:7001/public/blog1601870888667.jpeg'),(50,'http://121.199.1.64:7001/public/blog1601870947044.jpeg'),(51,'http://121.199.1.64:7001/public/blog1601871001006.jpeg'),(52,'http://121.199.1.64:7001/public/blog1601871064566.jpeg'),(53,'http://121.199.1.64:7001/public/blog1601871184007.jpeg'),(54,'http://121.199.1.64:7001/public/blog1601871244577.jpeg'),(55,'http://121.199.1.64:7001/public/blog1601871313249.jpeg'),(56,'http://121.199.1.64:7001/public/blog1601871369913.jpeg'),(57,'http://121.199.1.64:7001/public/blog1601871431950.jpeg'),(58,'http://121.199.1.64:7001/public/blog1601871480956.jpeg'),(59,'http://121.199.1.64:7001/public/blog1601871579239.jpeg'),(60,'http://121.199.1.64:7001/public/blog1601871631871.jpeg'),(61,'http://121.199.1.64:7001/public/blog1601871694208.jpeg'),(62,'http://121.199.1.64:7001/public/blog1601871753448.jpeg'),(63,'http://121.199.1.64:7001/public/blog1601871810820.jpeg'),(64,'http://121.199.1.64:7001/public/blog1601871922712.jpeg'),(65,'http://121.199.1.64:7001/public/blog1601871998868.jpeg'),(66,'http://121.199.1.64:7001/public/blog1601872041198.jpeg'),(67,'http://121.199.1.64:7001/public/blog1601872098121.jpeg'),(68,'http://121.199.1.64:7001/public/blog1609058955285.jpeg');
/*!40000 ALTER TABLE `image` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `type`
--

DROP TABLE IF EXISTS `type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `type` (
  `id` int(11) DEFAULT NULL,
  `typeName` varchar(20) DEFAULT NULL,
  `orderNum` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `type`
--

LOCK TABLES `type` WRITE;
/*!40000 ALTER TABLE `type` DISABLE KEYS */;
INSERT INTO `type` VALUES (1,'前端文章',1),(2,'读书杂谈',2),(3,'音乐爱好者',3),(4,'心情日记',4);
/*!40000 ALTER TABLE `type` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-02-17 10:37:53
